<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Space Shooter - Enhanced Edition</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <style>
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: radial-gradient(circle at center, #0a0a2e, #000);
      touch-action: manipulation;
      height: 100%;
      width: 100%;
      font-family: 'Orbitron', 'Arial', sans-serif;
    }

    @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap');

    canvas {
      display: block;
      background: linear-gradient(45deg, #0a0a2e, #16213e, #0a0a2e);
    }

    /* Hexagon Hearts Styles */
    .health-container {
      display: flex;
      align-items: center;
      gap: 12px;
      font-size: 28px;
      font-weight: bold;
      text-shadow: 2px 2px 4px black;
    }

    .hearts-container {
      display: flex;
      gap: 4px;
    }

    .hexagon-heart {
      width: 24px;
      height: 24px;
      position: relative;
      margin: 2px;
    }

    .hexagon-heart::before {
      content: '';
      position: absolute;
      width: 24px;
      height: 24px;
      background: transparent;
      border: 2px solid #ff6b6b;
      transform: rotate(45deg);
      transition: all 0.3s ease;
    }

    .hexagon-heart::after {
      content: '';
      position: absolute;
      width: 17px;
      height: 17px;
      background: transparent;
      border: 2px solid #ff6b6b;
      transform: rotate(45deg);
      top: 3.5px;
      left: 3.5px;
      transition: all 0.3s ease;
    }

    .hexagon-heart.filled::before {
      background: #ff6b6b;
      border-color: #ff6b6b;
      box-shadow: 0 0 12px rgba(255, 107, 107, 0.8);
    }

    .hexagon-heart.filled::after {
      background: #ff4444;
      border-color: #ff4444;
    }

    .hexagon-heart.empty::before,
    .hexagon-heart.empty::after {
      background: transparent;
      border-color: rgba(255, 107, 107, 0.3);
      animation: pulse-empty 2s infinite;
    }

    @keyframes pulse-empty {
      0%, 100% { opacity: 0.3; }
      50% { opacity: 0.6; }
    }

    .hexagon-heart.damage-animation {
      animation: damage-shake 0.6s ease-in-out;
    }

    @keyframes damage-shake {
      0%, 100% { transform: translateX(0); }
      10%, 30%, 50%, 70%, 90% { transform: translateX(-3px); }
      20%, 40%, 60%, 80% { transform: translateX(3px); }
    }

    .hexagon-heart.losing-life::before,
    .hexagon-heart.losing-life::after {
      animation: fade-out 0.5s ease-out forwards;
    }

    @keyframes fade-out {
      0% { 
        background: #ff6b6b;
        box-shadow: 0 0 12px rgba(255, 107, 107, 0.8);
        opacity: 1;
        transform: rotate(45deg) scale(1);
      }
      50% {
        transform: rotate(45deg) scale(1.2);
        opacity: 0.5;
      }
      100% { 
        background: transparent;
        box-shadow: none;
        opacity: 0.3;
        transform: rotate(45deg) scale(1);
      }
    }

    .hexagon-heart.heal-animation {
      animation: heal-pulse 0.8s ease-in-out;
    }

    @keyframes heal-pulse {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.3); }
    }

    .hexagon-heart.gaining-life::before,
    .hexagon-heart.gaining-life::after {
      animation: fade-in 0.6s ease-out forwards;
    }

    @keyframes fade-in {
      0% { 
        background: transparent;
        box-shadow: none;
        opacity: 0.3;
        transform: rotate(45deg) scale(0.5);
      }
      50% {
        transform: rotate(45deg) scale(1.2);
        opacity: 0.8;
      }
      100% { 
        background: #ff6b6b;
        box-shadow: 0 0 12px rgba(255, 107, 107, 0.8);
        opacity: 1;
        transform: rotate(45deg) scale(1);
      }
    }

    .hexagon-heart.powerup-glow::before {
      animation: powerup-glow 0.8s ease-in-out;
    }

    @keyframes powerup-glow {
      0%, 100% { box-shadow: 0 0 12px rgba(255, 107, 107, 0.8); }
      50% { box-shadow: 0 0 25px rgba(255, 215, 0, 1), 0 0 35px rgba(255, 107, 107, 0.8); }
    }

    /* Enhanced HUD */
    #hud {
      position: absolute;
      top: 20px;
      left: 20px;
      color: white;
      font-family: 'Orbitron', sans-serif;
      font-size: 18px;
      font-weight: 700;
      z-index: 10;
      text-shadow: 0 0 10px rgba(0, 255, 255, 0.7);
      background: rgba(0, 0, 0, 0.3);
      padding: 15px;
      border-radius: 10px;
      border: 1px solid rgba(0, 255, 255, 0.3);
      backdrop-filter: blur(5px);
    }

    .hud-item {
      margin-bottom: 8px;
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .hud-label {
      color: #00ffff;
      text-shadow: 0 0 5px rgba(0, 255, 255, 0.5);
    }

    .hud-value {
      color: #ffffff;
      font-weight: 900;
    }

    .difficulty-indicator {
      color: #ffaa00;
      font-size: 14px;
      text-shadow: 0 0 5px rgba(255, 170, 0, 0.8);
    }

    .difficulty-hard {
      color: #ff4444;
      text-shadow: 0 0 5px rgba(255, 68, 68, 0.8);
    }

    /* Boss Health Bar */
    #boss-health-container {
      position: absolute;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      width: 400px;
      display: none;
      z-index: 15;
    }

    .boss-health-bar {
      width: 100%;
      height: 20px;
      background: rgba(0, 0, 0, 0.7);
      border: 2px solid #ff4444;
      border-radius: 10px;
      overflow: hidden;
      position: relative;
    }

    .boss-health-fill {
      height: 100%;
      background: linear-gradient(90deg, #ff4444, #ffaa00, #ff4444);
      width: 100%;
      transition: width 0.3s ease;
      box-shadow: 0 0 15px rgba(255, 68, 68, 0.8);
    }

    .boss-name {
      text-align: center;
      color: #ff4444;
      font-family: 'Orbitron', sans-serif;
      font-weight: 900;
      font-size: 16px;
      margin-bottom: 5px;
      text-shadow: 0 0 10px rgba(255, 68, 68, 1);
      animation: boss-name-glow 2s ease-in-out infinite alternate;
    }

    @keyframes boss-name-glow {
      0% { text-shadow: 0 0 10px rgba(255, 68, 68, 1); }
      100% { text-shadow: 0 0 20px rgba(255, 68, 68, 1), 0 0 30px rgba(255, 68, 68, 0.5); }
    }

    /* Fullscreen Button */
    #fullscreen-btn {
      position: absolute;
      top: 20px;
      right: 20px;
      background: rgba(0, 255, 255, 0.2);
      border: 2px solid rgba(0, 255, 255, 0.5);
      color: #00ffff;
      padding: 10px 15px;
      border-radius: 8px;
      font-family: 'Orbitron', sans-serif;
      font-weight: 700;
      cursor: pointer;
      z-index: 20;
      backdrop-filter: blur(5px);
      transition: all 0.3s ease;
    }

    #fullscreen-btn:hover {
      background: rgba(0, 255, 255, 0.3);
      border-color: rgba(0, 255, 255, 0.8);
      transform: translateY(-2px);
    }

    /* Enhanced Mobile Controls - More Compact */
    #mobile-controls {
      position: fixed;
      bottom: 15px;
      left: 15px;
      right: 15px;
      display: flex;
      justify-content: space-between;
      align-items: flex-end;
      width: calc(100% - 30px);
      z-index: 20;
      pointer-events: none;
    }

    #joystick-container {
      position: relative;
      width: 120px;
      height: 120px;
      background: radial-gradient(circle, rgba(0, 255, 255, 0.15), rgba(0, 255, 255, 0.03));
      border-radius: 50%;
      border: 2px solid rgba(0, 255, 255, 0.3);
      display: flex;
      justify-content: center;
      align-items: center;
      flex-shrink: 0;
      box-shadow: 0 0 15px rgba(0, 255, 255, 0.2);
      pointer-events: auto;
      touch-action: none;
      user-select: none;
    }

    #joystick {
      width: 60px;
      height: 60px;
      background: radial-gradient(circle, rgba(255, 255, 255, 0.8), rgba(0, 255, 255, 0.5));
      border-radius: 50%;
      position: absolute;
      touch-action: none;
      left: calc(50% - 30px);
      top: calc(50% - 30px);
      border: 2px solid rgba(255, 255, 255, 0.7);
      box-shadow: 0 0 10px rgba(0, 255, 255, 0.4);
      transition: transform 0.1s ease;
      pointer-events: none;
      user-select: none;
    }

    #joystick.active {
      transform: scale(0.95);
      box-shadow: 0 0 20px rgba(0, 255, 255, 0.7);
    }

    #shoot-button {
      width: 120px;
      height: 120px;
      background: radial-gradient(circle, rgba(255, 50, 50, 0.25), rgba(255, 0, 0, 0.08));
      border-radius: 50%;
      display: flex;
      justify-content: center;
      align-items: center;
      color: white;
      font-family: 'Orbitron', sans-serif;
      font-size: 20px;
      font-weight: 900;
      text-shadow: 0 0 8px rgba(255, 50, 50, 0.7);
      box-shadow: 0 0 15px rgba(255, 50, 50, 0.3);
      border: 2px solid rgba(255, 50, 50, 0.5);
      position: relative;
      overflow: hidden;
      transition: all 0.1s ease;
      cursor: pointer;
      user-select: none;
      pointer-events: auto;
      touch-action: manipulation;
    }

    #shoot-button::before {
      content: "";
      position: absolute;
      width: 100%;
      height: 100%;
      background: radial-gradient(circle, rgba(255, 100, 100, 0.3), transparent 70%);
      opacity: 0;
      transition: opacity 0.3s;
    }

    #shoot-button.active {
      transform: scale(0.95);
      box-shadow: 0 0 25px rgba(255, 50, 50, 0.7);
    }

    #shoot-button.active::before {
      opacity: 1;
    }

    /* Ship Customization Screen */
    #customization-screen {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: radial-gradient(circle, rgba(0, 0, 0, 0.95), rgba(0, 0, 0, 0.8));
      color: white;
      font-family: 'Orbitron', sans-serif;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 160;
      padding: 20px;
      box-sizing: border-box;
      text-align: center;
      backdrop-filter: blur(10px);
      display: none;
    }

    #customization-screen h1 {
      font-size: 5vw;
      margin-bottom: 30px;
      color: #00ffff;
      text-shadow: 0 0 30px rgba(0, 255, 255, 1);
      animation: title-glow 2s ease-in-out infinite alternate;
    }

    .customization-content {
      display: flex;
      flex-wrap: wrap;
      gap: 30px;
      justify-content: center;
      align-items: flex-start;
      max-width: 1200px;
      width: 100%;
    }

    .ship-preview {
      background: rgba(0, 0, 0, 0.7);
      border: 2px solid rgba(0, 255, 255, 0.5);
      border-radius: 15px;
      padding: 20px;
      min-width: 300px;
      flex: 1;
      max-width: 400px;
    }

    .ship-preview h3 {
      color: #00ffff;
      margin-bottom: 15px;
      font-size: 1.4em;
    }

    .ship-canvas {
      width: 200px;
      height: 150px;
      background: rgba(0, 20, 40, 0.8);
      border: 1px solid rgba(0, 255, 255, 0.3);
      border-radius: 10px;
      margin: 0 auto 15px;
      display: block;
    }

    .ship-stats {
      text-align: left;
      font-size: 0.9em;
    }

    .stat-bar {
      display: flex;
      align-items: center;
      margin: 8px 0;
      gap: 10px;
    }

    .stat-label {
      width: 80px;
      color: #00ffff;
    }

    .stat-value {
      flex: 1;
      height: 8px;
      background: rgba(255, 255, 255, 0.2);
      border-radius: 4px;
      overflow: hidden;
    }

    .stat-fill {
      height: 100%;
      border-radius: 4px;
      transition: width 0.3s ease;
    }

    .stat-fill.speed { background: linear-gradient(90deg, #00ff88, #00dd66); }
    .stat-fill.power { background: linear-gradient(90deg, #ff4444, #cc0000); }
    .stat-fill.defense { background: linear-gradient(90deg, #00aaff, #0088cc); }

    .ship-selection {
      flex: 2;
      min-width: 400px;
    }

    .ship-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
      gap: 15px;
      margin-bottom: 20px;
    }

    .ship-option {
      background: rgba(0, 0, 0, 0.6);
      border: 2px solid rgba(255, 255, 255, 0.3);
      border-radius: 10px;
      padding: 15px;
      cursor: pointer;
      transition: all 0.3s ease;
      text-align: center;
    }

    .ship-option:hover {
      border-color: rgba(0, 255, 255, 0.8);
      transform: translateY(-2px);
      box-shadow: 0 5px 20px rgba(0, 255, 255, 0.3);
    }

    .ship-option.selected {
      border-color: #00ffff;
      background: rgba(0, 255, 255, 0.1);
      box-shadow: 0 0 20px rgba(0, 255, 255, 0.5);
    }

    .ship-option h4 {
      margin: 10px 0 5px;
      color: #ffffff;
      font-size: 1.1em;
    }

    .ship-option .ship-theme {
      font-size: 0.8em;
      opacity: 0.8;
      margin-bottom: 10px;
    }

    .mini-ship-canvas {
      width: 120px;
      height: 80px;
      background: rgba(0, 20, 40, 0.6);
      border: 1px solid rgba(0, 255, 255, 0.2);
      border-radius: 5px;
      margin: 0 auto 10px;
      display: block;
    }

    .customization-buttons {
      display: flex;
      gap: 20px;
      margin-top: 30px;
      flex-wrap: wrap;
      justify-content: center;
    }

    .customization-btn {
      padding: 15px 30px;
      font-size: 1.2em;
      font-family: 'Orbitron', sans-serif;
      font-weight: 700;
      border: none;
      border-radius: 10px;
      cursor: pointer;
      transition: all 0.3s ease;
      text-transform: uppercase;
      letter-spacing: 1px;
      min-width: 150px;
    }

    .customization-btn.start {
      background: linear-gradient(45deg, #00ff88, #00cc66);
      color: black;
      box-shadow: 0 0 20px rgba(0, 255, 136, 0.5);
    }

    .customization-btn.start:hover {
      background: linear-gradient(45deg, #00cc66, #00aa44);
      transform: translateY(-2px);
      box-shadow: 0 5px 25px rgba(0, 255, 136, 0.8);
    }

    .customization-btn.back {
      background: linear-gradient(45deg, #666, #444);
      color: white;
      box-shadow: 0 0 20px rgba(100, 100, 100, 0.5);
    }

    .customization-btn.back:hover {
      background: linear-gradient(45deg, #555, #333);
      transform: translateY(-2px);
      box-shadow: 0 5px 25px rgba(100, 100, 100, 0.8);
    }

    /* Difficulty Selection */
    #difficulty-screen {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: radial-gradient(circle, rgba(0, 0, 0, 0.9), rgba(0, 0, 0, 0.7));
      color: white;
      font-family: 'Orbitron', sans-serif;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 150;
      padding: 20px;
      box-sizing: border-box;
      text-align: center;
      backdrop-filter: blur(10px);
    }

    #difficulty-screen h1 {
      font-size: 6vw;
      margin-bottom: 30px;
      color: #00ffff;
      text-shadow: 0 0 30px rgba(0, 255, 255, 1);
      animation: title-glow 2s ease-in-out infinite alternate;
    }

    @keyframes title-glow {
      0% { text-shadow: 0 0 30px rgba(0, 255, 255, 1); }
      100% { text-shadow: 0 0 50px rgba(0, 255, 255, 1), 0 0 80px rgba(0, 255, 255, 0.5); }
    }

    .difficulty-buttons {
      display: flex;
      flex-direction: column;
      gap: 20px;
      margin-top: 20px;
    }

    .difficulty-btn {
      padding: 20px 40px;
      font-size: 1.5em;
      font-family: 'Orbitron', sans-serif;
      font-weight: 700;
      border: none;
      border-radius: 15px;
      cursor: pointer;
      transition: all 0.3s ease;
      text-transform: uppercase;
      letter-spacing: 2px;
      min-width: 250px;
    }

    .difficulty-btn.easy {
      background: linear-gradient(45deg, #00ff88, #00cc66);
      color: black;
      box-shadow: 0 0 20px rgba(0, 255, 136, 0.5);
    }

    .difficulty-btn.easy:hover {
      background: linear-gradient(45deg, #00cc66, #00aa44);
      transform: translateY(-2px);
      box-shadow: 0 5px 25px rgba(0, 255, 136, 0.8);
    }

    .difficulty-btn.hard {
      background: linear-gradient(45deg, #ff4444, #cc0000);
      color: white;
      box-shadow: 0 0 20px rgba(255, 68, 68, 0.5);
    }

    .difficulty-btn.hard:hover {
      background: linear-gradient(45deg, #cc0000, #aa0000);
      transform: translateY(-2px);
      box-shadow: 0 5px 25px rgba(255, 68, 68, 0.8);
    }

    .difficulty-description {
      font-size: 0.9em;
      margin-top: 10px;
      opacity: 0.8;
      line-height: 1.4;
    }

    /* Enhanced Game Over Screen */
    #game-over-screen {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: radial-gradient(circle, rgba(0, 0, 0, 0.9), rgba(0, 0, 0, 0.7));
      color: white;
      font-family: 'Orbitron', sans-serif;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      text-shadow: 0 0 20px rgba(255, 50, 50, 0.8);
      z-index: 100;
      display: none;
      padding: 20px;
      box-sizing: border-box;
      text-align: center;
      backdrop-filter: blur(10px);
    }

    #game-over-screen h1 {
      font-size: 8vw;
      margin-bottom: 20px;
      line-height: 1;
      color: #ff3333;
      text-shadow: 0 0 30px rgba(255, 50, 50, 1);
      animation: game-over-glow 2s ease-in-out infinite alternate;
    }

    @keyframes game-over-glow {
      0% { text-shadow: 0 0 30px rgba(255, 50, 50, 1); }
      100% { text-shadow: 0 0 50px rgba(255, 50, 50, 1), 0 0 80px rgba(255, 50, 50, 0.5); }
    }

    #game-over-screen p {
      font-size: 4vw;
      margin: 10px 0;
      color: #00ffff;
      text-shadow: 0 0 15px rgba(0, 255, 255, 0.8);
    }

    #game-over-screen button {
      padding: 20px 40px;
      font-size: 1.5em;
      font-family: 'Orbitron', sans-serif;
      font-weight: 700;
      background: linear-gradient(45deg, #00ffff, #0080ff);
      color: black;
      border: none;
      border-radius: 15px;
      cursor: pointer;
      box-shadow: 0 0 20px rgba(0, 255, 255, 0.5);
      transition: all 0.3s ease;
      text-transform: uppercase;
      letter-spacing: 2px;
      margin: 10px;
    }

    #game-over-screen button:hover {
      background: linear-gradient(45deg, #00cccc, #0066cc);
      transform: translateY(-2px);
      box-shadow: 0 5px 25px rgba(0, 255, 255, 0.8);
    }

    /* Responsive Design - Enhanced Mobile Optimization */
    @media (max-width: 600px) {
      #hud {
        font-size: 12px;
        padding: 8px;
        top: 5px;
        left: 5px;
        right: 5px;
        width: auto;
        max-width: calc(100vw - 10px);
        box-sizing: border-box;
      }

      .hud-item {
        margin-bottom: 4px;
        gap: 6px;
      }

      .health-container {
        font-size: 14px;
        gap: 6px;
      }
      
      .hexagon-heart {
        width: 16px;
        height: 16px;
      }

      .hexagon-heart::before {
        width: 16px;
        height: 16px;
      }

      .hexagon-heart::after {
        width: 10px;
        height: 10px;
        top: 3px;
        left: 3px;
      }

      #boss-health-container {
        width: 90%;
        top: 5px;
      }

      .boss-name {
        font-size: 12px;
      }

      #mobile-controls {
        bottom: 10px;
        left: 10px;
        right: 10px;
      }

      #joystick-container {
        width: 100px;
        height: 100px;
      }

      #joystick {
        width: 50px;
        height: 50px;
        left: calc(50% - 25px);
        top: calc(50% - 25px);
      }

      #shoot-button {
        width: 100px;
        height: 100px;
        font-size: 16px;
      }

      #fullscreen-btn {
        top: 5px;
        right: 5px;
        padding: 8px 12px;
        font-size: 12px;
      }

      #game-over-screen h1 {
        font-size: 12vw;
      }

      #game-over-screen p {
        font-size: 6vw;
      }

      #difficulty-screen h1 {
        font-size: 10vw;
      }

      #customization-screen h1 {
        font-size: 8vw;
        margin-bottom: 15px;
      }

      .customization-content {
        flex-direction: column;
        gap: 20px;
        max-height: 60vh;
        overflow-y: auto;
        padding: 10px;
      }

      .ship-preview {
        min-width: auto;
        max-width: none;
        padding: 15px;
        margin-bottom: 10px;
      }

      .ship-selection {
        min-width: auto;
        margin-bottom: 20px;
      }

      .ship-grid {
        grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
        gap: 10px;
      }

      .mini-ship-canvas {
        width: 80px;
        height: 50px;
      }

      .difficulty-btn {
        font-size: 1.0em;
        padding: 15px 25px;
        min-width: 180px;
      }

      .customization-buttons {
        flex-direction: column;
        align-items: center;
        position: fixed;
        bottom: 20px;
        left: 50%;
        transform: translateX(-50%);
        background: rgba(0, 0, 0, 0.9);
        padding: 15px;
        border-radius: 15px;
        border: 1px solid rgba(0, 255, 255, 0.3);
        backdrop-filter: blur(10px);
        z-index: 170;
        gap: 10px;
        width: calc(100% - 40px);
        max-width: 400px;
        box-sizing: border-box;
      }

      .customization-btn {
        width: 100%;
        padding: 12px 20px;
        font-size: 1.1em;
        margin: 0;
      }

      /* Ensure content doesn't overlap with fixed buttons */
      #customization-screen {
        padding-bottom: 120px;
      }

      .ship-stats {
        font-size: 0.8em;
      }

      .stat-bar {
        margin: 6px 0;
      }

      .stat-label {
        width: 60px;
        font-size: 0.9em;
      }

      .ship-option h4 {
        font-size: 1em;
        margin: 8px 0 4px;
      }

      .ship-option .ship-theme {
        font-size: 0.7em;
        margin-bottom: 8px;
      }

      .ship-option {
        padding: 10px;
      }

      /* Better scrolling for mobile */
      .customization-content::-webkit-scrollbar {
        width: 4px;
      }

      .customization-content::-webkit-scrollbar-track {
        background: rgba(255, 255, 255, 0.1);
        border-radius: 2px;
      }

      .customization-content::-webkit-scrollbar-thumb {
        background: rgba(0, 255, 255, 0.5);
        border-radius: 2px;
      }

      .customization-content::-webkit-scrollbar-thumb:hover {
        background: rgba(0, 255, 255, 0.8);
      }

      /* Compact ship preview for mobile */
      .ship-canvas {
        width: 150px;
        height: 100px;
        margin-bottom: 10px;
      }

      .ship-preview h3 {
        font-size: 1.2em;
        margin-bottom: 10px;
      }

      .ship-selection h3 {
        font-size: 1.2em;
        margin-bottom: 15px;
      }
    }

    /* Extra small screens */
    @media (max-width: 400px) {
      #hud {
        font-size: 10px;
        padding: 6px;
      }

      .health-container {
        font-size: 12px;
      }

      .hexagon-heart {
        width: 14px;
        height: 14px;
      }

      #mobile-controls {
        bottom: 8px;
        left: 8px;
        right: 8px;
      }

      #joystick-container {
        width: 90px;
        height: 90px;
      }

      #joystick {
        width: 45px;
        height: 45px;
        left: calc(50% - 22.5px);
        top: calc(50% - 22.5px);
      }

      #shoot-button {
        width: 90px;
        height: 90px;
        font-size: 14px;
      }
    }

    /* Loading Screen */
    #loading-screen {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: radial-gradient(circle, #0a0a2e, #000);
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 200;
      color: white;
      font-family: 'Orbitron', sans-serif;
    }

    .loading-text {
      font-size: 2em;
      margin-bottom: 30px;
      text-shadow: 0 0 20px rgba(0, 255, 255, 0.8);
      animation: loading-pulse 2s ease-in-out infinite;
    }

    @keyframes loading-pulse {
      0%, 100% { opacity: 0.5; }
      50% { opacity: 1; }
    }

    .loading-bar {
      width: 300px;
      height: 4px;
      background: rgba(255, 255, 255, 0.1);
      border-radius: 2px;
      overflow: hidden;
    }

    .loading-progress {
      height: 100%;
      background: linear-gradient(90deg, #00ffff, #0080ff);
      width: 0%;
      transition: width 0.3s ease;
      box-shadow: 0 0 10px rgba(0, 255, 255, 0.8);
    }

    /* Boss Warning */
    #boss-warning {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(255, 0, 0, 0.1);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 50;
      display: none;
      pointer-events: none;
    }

    .boss-warning-text {
      font-family: 'Orbitron', sans-serif;
      font-size: 6vw;
      font-weight: 900;
      color: #ff4444;
      text-shadow: 0 0 30px rgba(255, 68, 68, 1);
      animation: boss-warning-pulse 0.5s ease-in-out infinite alternate;
      text-align: center;
      line-height: 1.2;
    }

    @keyframes boss-warning-pulse {
      0% { 
        opacity: 0.8;
        transform: scale(1);
      }
      100% { 
        opacity: 1;
        transform: scale(1.05);
      }
    }
  </style>
</head>
<body>
  <div id="loading-screen">
    <div class="loading-text">INITIALIZING SPACE SHOOTER</div>
    <div class="loading-bar">
      <div class="loading-progress" id="loading-progress"></div>
    </div>
  </div>

  <div id="difficulty-screen">
    <h1>SELECT DIFFICULTY</h1>
    <div class="difficulty-buttons">
      <button class="difficulty-btn easy" id="easy-btn">
        EASY MODE
        <div class="difficulty-description">Standard gameplay - enemies don't shoot back</div>
      </button>
      <button class="difficulty-btn hard" id="hard-btn">
        HARD MODE
        <div class="difficulty-description">Intense combat - enemies shoot back at you!</div>
      </button>
    </div>
  </div>

  <div id="customization-screen">
    <h1>SHIP CUSTOMIZATION</h1>
    <div class="customization-content">
      <div class="ship-preview">
        <h3>Ship Preview</h3>
        <canvas class="ship-canvas" id="preview-canvas" width="200" height="150"></canvas>
        <div class="ship-stats">
          <div class="stat-bar">
            <span class="stat-label">Speed:</span>
            <div class="stat-value">
              <div class="stat-fill speed" id="speed-stat"></div>
            </div>
          </div>
          <div class="stat-bar">
            <span class="stat-label">Power:</span>
            <div class="stat-value">
              <div class="stat-fill power" id="power-stat"></div>
            </div>
          </div>
          <div class="stat-bar">
            <span class="stat-label">Defense:</span>
            <div class="stat-value">
              <div class="stat-fill defense" id="defense-stat"></div>
            </div>
          </div>
        </div>
      </div>
      
      <div class="ship-selection">
        <h3>Choose Your Ship</h3>
        <div class="ship-grid" id="ship-grid">
          <!-- Ship options will be populated by JavaScript -->
        </div>
      </div>
    </div>
    
    <div class="customization-buttons">
      <button class="customization-btn start" id="start-game-btn">Launch Mission</button>
      <button class="customization-btn back" id="back-to-difficulty-btn">Back</button>
    </div>
  </div>

  <canvas id="game"></canvas>

  <!-- Fullscreen Button -->
  <button id="fullscreen-btn" style="display: none;">⛶ FULLSCREEN</button>

  <div id="boss-warning">
    <div class="boss-warning-text">
      ⚠️ BOSS INCOMING ⚠️<br>
      PREPARE FOR BATTLE!
    </div>
  </div>

  <div id="boss-health-container">
    <div class="boss-name" id="boss-name">VOID DESTROYER</div>
    <div class="boss-health-bar">
      <div class="boss-health-fill" id="boss-health-fill"></div>
    </div>
  </div>

  <div id="hud">
    <div class="hud-item health-container">
      <span class="hud-label">HP:</span>
      <div class="hearts-container" id="hearts-container"></div>
    </div>
    <div class="hud-item">
      <span class="hud-label">SCORE:</span>
      <span class="hud-value" id="score">0</span>
    </div>
    <div class="hud-item">
      <span class="hud-label">SHIELD:</span>
      <span class="hud-value" id="shield-time">0</span>
    </div>
    <div class="hud-item">
      <span class="hud-label">DIFFICULTY:</span>
      <span class="hud-value difficulty-indicator" id="difficulty-display">EASY</span>
    </div>
    <div class="hud-item">
      <span class="hud-label">SHIP:</span>
      <span class="hud-value" id="ship-name-display">CYBER STRIKER</span>
    </div>
  </div>

  <div id="mobile-controls">
    <div id="joystick-container">
      <div id="joystick"></div>
    </div>
    <div id="shoot-button">FIRE</div>
  </div>

  <div id="game-over-screen">
    <h1>GAME OVER</h1>
    <p>FINAL SCORE: <span id="final-score">0</span></p>
    <button id="restart-button">RESTART MISSION</button>
    <button id="customize-button">CUSTOMIZE SHIP</button>
    <button id="difficulty-button">CHANGE DIFFICULTY</button>
  </div>

  <script>
    // Fullscreen API implementation with cross-browser support
    class FullscreenManager {
      constructor() {
        this.isFullscreen = false;
        this.fullscreenBtn = document.getElementById('fullscreen-btn');
        this.bindEvents();
      }

      bindEvents() {
        this.fullscreenBtn.addEventListener('click', () => this.toggleFullscreen());
        
        // Listen for fullscreen changes
        document.addEventListener('fullscreenchange', () => this.handleFullscreenChange());
        document.addEventListener('webkitfullscreenchange', () => this.handleFullscreenChange());
        document.addEventListener('mozfullscreenchange', () => this.handleFullscreenChange());
        document.addEventListener('MSFullscreenChange', () => this.handleFullscreenChange());
      }

      async enterFullscreen() {
        try {
          const element = document.documentElement;
          
          if (element.requestFullscreen) {
            await element.requestFullscreen();
          } else if (element.webkitRequestFullscreen) {
            await element.webkitRequestFullscreen();
          } else if (element.mozRequestFullScreen) {
            await element.mozRequestFullScreen();
          } else if (element.msRequestFullscreen) {
            await element.msRequestFullscreen();
          }
          
          return true;
        } catch (error) {
          console.warn('Fullscreen request failed:', error);
          return false;
        }
      }

      async exitFullscreen() {
        try {
          if (document.exitFullscreen) {
            await document.exitFullscreen();
          } else if (document.webkitExitFullscreen) {
            await document.webkitExitFullscreen();
          } else if (document.mozCancelFullScreen) {
            await document.mozCancelFullScreen();
          } else if (document.msExitFullscreen) {
            await document.msExitFullscreen();
          }
          
          return true;
        } catch (error) {
          console.warn('Exit fullscreen failed:', error);
          return false;
        }
      }

      async toggleFullscreen() {
        if (this.isFullscreenSupported()) {
          if (this.isFullscreen) {
            await this.exitFullscreen();
          } else {
            await this.enterFullscreen();
          }
        }
      }

      isFullscreenSupported() {
        return !!(
          document.fullscreenEnabled ||
          document.webkitFullscreenEnabled ||
          document.mozFullScreenEnabled ||
          document.msFullscreenEnabled
        );
      }

      handleFullscreenChange() {
        this.isFullscreen = !!(
          document.fullscreenElement ||
          document.webkitFullscreenElement ||
          document.mozFullScreenElement ||
          document.msFullscreenElement
        );

        this.fullscreenBtn.textContent = this.isFullscreen ? '⛶ EXIT FULLSCREEN' : '⛶ FULLSCREEN';
        
        // Resize canvas when fullscreen changes
        setTimeout(() => {
          resizeCanvas();
        }, 100);
      }

      async autoEnterFullscreen() {
        if (this.isFullscreenSupported() && !this.isFullscreen) {
          await this.enterFullscreen();
        }
      }

      show() {
        this.fullscreenBtn.style.display = 'block';
      }

      hide() {
        this.fullscreenBtn.style.display = 'none';
      }
    }

    // Initialize fullscreen manager
    const fullscreenManager = new FullscreenManager();

    // Loading screen
    let loadingProgress = 0;
    const loadingProgressBar = document.getElementById('loading-progress');
    const loadingScreen = document.getElementById('loading-screen');
    const difficultyScreen = document.getElementById('difficulty-screen');
    const customizationScreen = document.getElementById('customization-screen');

    function updateLoadingProgress() {
      loadingProgress += Math.random() * 15 + 5;
      loadingProgressBar.style.width = Math.min(loadingProgress, 100) + '%';
      
      if (loadingProgress >= 100) {
        setTimeout(() => {
          loadingScreen.style.display = 'none';
          showDifficultyScreen();
        }, 500);
      } else {
        setTimeout(updateLoadingProgress, 100);
      }
    }

    function showDifficultyScreen() {
      difficultyScreen.style.display = 'flex';
    }

    function hideDifficultyScreen() {
      difficultyScreen.style.display = 'none';
      showCustomizationScreen();
    }

    function showCustomizationScreen() {
      customizationScreen.style.display = 'flex';
      initializeShipCustomization();
    }

    function hideCustomizationScreen() {
      customizationScreen.style.display = 'none';
      fullscreenManager.show();
      resizeCanvas();
      initGame();
      
      // Auto-enter fullscreen when game starts
      setTimeout(() => {
        fullscreenManager.autoEnterFullscreen();
      }, 500);
    }

    // Start loading
    updateLoadingProgress();

    // Game variables
    const canvas = document.getElementById("game");
    const ctx = canvas.getContext("2d");

    let mouse = { x: 0, y: 0 };
    let keys = {};
    let lives = 3;
    let score = 0;
    let powerUps = [];
    let particles = [];
    let explosions = [];
    let enemyBullets = [];
    let shieldActive = false;
    let shieldTimer = 0;
    let gameRunning = false;
    let animationFrameId;
    let currentLives = 3;
    let difficulty = 'easy';
    let selectedShip = 'striker';
    let currentBoss = null;
    let bossActive = false;
    let enemiesKilled = 0;
    let nextBossAt = 20;
    const maxLives = 6;

    // Ship configurations
    const shipConfigs = {
      striker: {
        name: 'Cyber Striker',
        theme: 'Cyber Blue',
        speed: 85,
        power: 70,
        defense: 60,
        speedMultiplier: 1.0,
        powerMultiplier: 1.0,
        defenseMultiplier: 1.0,
        colors: {
          primary: '#00ffff',
          secondary: '#0080ff',
          accent: '#ffffff'
        }
      },
      hunter: {
        name: 'Plasma Hunter',
        theme: 'Plasma Red',
        speed: 90,
        power: 85,
        defense: 50,
        speedMultiplier: 1.1,
        powerMultiplier: 1.2,
        defenseMultiplier: 0.9,
        colors: {
          primary: '#ff4444',
          secondary: '#cc0000',
          accent: '#ffaaaa'
        }
      },
      guardian: {
        name: 'Void Guardian',
        theme: 'Void Purple',
        speed: 60,
        power: 60,
        defense: 95,
        speedMultiplier: 0.8,
        powerMultiplier: 0.9,
        defenseMultiplier: 1.3,
        colors: {
          primary: '#aa44ff',
          secondary: '#6600aa',
          accent: '#ddaaff'
        }
      },
      interceptor: {
        name: 'Solar Interceptor',
        theme: 'Solar Gold',
        speed: 100,
        power: 75,
        defense: 40,
        speedMultiplier: 1.3,
        powerMultiplier: 1.1,
        defenseMultiplier: 0.7,
        colors: {
          primary: '#ffdd00',
          secondary: '#cc9900',
          accent: '#ffff88'
        }
      }
    };

    const isMobile = /Mobi|Android/i.test(navigator.userAgent);
    const scoreSpan = document.getElementById("score");
    const shieldTimeSpan = document.getElementById("shield-time");
    const difficultyDisplay = document.getElementById("difficulty-display");
    const shipNameDisplay = document.getElementById("ship-name-display");
    const gameOverScreen = document.getElementById("game-over-screen");
    const finalScoreSpan = document.getElementById("final-score");
    const restartButton = document.getElementById("restart-button");
    const customizeButton = document.getElementById("customize-button");
    const difficultyButton = document.getElementById("difficulty-button");
    const mobileControlsDiv = document.getElementById("mobile-controls");
    const joystickContainer = document.getElementById("joystick-container");
    const joystick = document.getElementById("joystick");
    const shootButton = document.getElementById("shoot-button");
    const easyBtn = document.getElementById("easy-btn");
    const hardBtn = document.getElementById("hard-btn");
    const bossHealthContainer = document.getElementById("boss-health-container");
    const bossHealthFill = document.getElementById("boss-health-fill");
    const bossName = document.getElementById("boss-name");
    const bossWarning = document.getElementById("boss-warning");

    // Difficulty selection
    easyBtn.addEventListener('click', () => {
      difficulty = 'easy';
      difficultyDisplay.textContent = 'EASY';
      difficultyDisplay.className = 'hud-value difficulty-indicator';
      hideDifficultyScreen();
    });

    hardBtn.addEventListener('click', () => {
      difficulty = 'hard';
      difficultyDisplay.textContent = 'HARD';
      difficultyDisplay.className = 'hud-value difficulty-indicator difficulty-hard';
      hideDifficultyScreen();
    });

    // Ship customization
    function initializeShipCustomization() {
      const shipGrid = document.getElementById('ship-grid');
      const previewCanvas = document.getElementById('preview-canvas');
      const previewCtx = previewCanvas.getContext('2d');
      
      shipGrid.innerHTML = '';
      
      Object.keys(shipConfigs).forEach(shipKey => {
        const config = shipConfigs[shipKey];
        const shipOption = document.createElement('div');
        shipOption.className = 'ship-option';
        if (shipKey === selectedShip) {
          shipOption.classList.add('selected');
        }
        
        shipOption.innerHTML = `
          <canvas class="mini-ship-canvas" width="120" height="80"></canvas>
          <h4>${config.name}</h4>
          <div class="ship-theme">${config.theme}</div>
        `;
        
        const miniCanvas = shipOption.querySelector('.mini-ship-canvas');
        const miniCtx = miniCanvas.getContext('2d');
        drawShipPreview(miniCtx, 60, 40, shipKey, 0.7);
        
        shipOption.addEventListener('click', () => {
          document.querySelectorAll('.ship-option').forEach(opt => opt.classList.remove('selected'));
          shipOption.classList.add('selected');
          selectedShip = shipKey;
          updateShipPreview();
        });
        
        shipGrid.appendChild(shipOption);
      });
      
      updateShipPreview();
    }

    function updateShipPreview() {
      const previewCanvas = document.getElementById('preview-canvas');
      const previewCtx = previewCanvas.getContext('2d');
      const config = shipConfigs[selectedShip];
      
      // Clear canvas
      previewCtx.fillStyle = 'rgba(0, 20, 40, 0.8)';
      previewCtx.fillRect(0, 0, previewCanvas.width, previewCanvas.height);
      
      // Draw ship
      drawShipPreview(previewCtx, 100, 75, selectedShip, 1.5);
      
      // Update stats
      document.getElementById('speed-stat').style.width = config.speed + '%';
      document.getElementById('power-stat').style.width = config.power + '%';
      document.getElementById('defense-stat').style.width = config.defense + '%';
      
      // Update ship name in HUD
      shipNameDisplay.textContent = config.name.toUpperCase();
    }

    function drawShipPreview(ctx, x, y, shipType, scale = 1) {
      const config = shipConfigs[shipType];
      ctx.save();
      ctx.translate(x, y);
      ctx.scale(scale, scale);
      
      ctx.shadowBlur = 10;
      ctx.shadowColor = config.colors.primary;
      
      if (shipType === 'striker') {
        // Cyber Striker - Angular design
        ctx.fillStyle = config.colors.primary;
        ctx.beginPath();
        ctx.moveTo(20, 0);
        ctx.lineTo(-15, -10);
        ctx.lineTo(-10, -6);
        ctx.lineTo(-10, 6);
        ctx.lineTo(-15, 10);
        ctx.closePath();
        ctx.fill();
        
        ctx.fillStyle = config.colors.secondary;
        ctx.beginPath();
        ctx.moveTo(-10, -6);
        ctx.lineTo(-15, -10);
        ctx.lineTo(-10, -8);
        ctx.closePath();
        ctx.fill();
        
        ctx.beginPath();
        ctx.moveTo(-10, 6);
        ctx.lineTo(-15, 10);
        ctx.lineTo(-10, 8);
        ctx.closePath();
        ctx.fill();
        
      } else if (shipType === 'hunter') {
        // Plasma Hunter - Aggressive design
        ctx.fillStyle = config.colors.primary;
        ctx.beginPath();
        ctx.moveTo(22, 0);
        ctx.lineTo(-12, -12);
        ctx.lineTo(-18, -8);
        ctx.lineTo(-8, 0);
        ctx.lineTo(-18, 8);
        ctx.lineTo(-12, 12);
        ctx.closePath();
        ctx.fill();
        
        ctx.fillStyle = config.colors.secondary;
        ctx.beginPath();
        ctx.moveTo(15, -4);
        ctx.lineTo(18, 0);
        ctx.lineTo(15, 4);
        ctx.closePath();
        ctx.fill();
        
      } else if (shipType === 'guardian') {
        // Void Guardian - Bulky design
        ctx.fillStyle = config.colors.primary;
        ctx.beginPath();
        ctx.moveTo(18, 0);
        ctx.lineTo(-16, -14);
        ctx.lineTo(-20, -10);
        ctx.lineTo(-20, 10);
        ctx.lineTo(-16, 14);
        ctx.closePath();
        ctx.fill();
        
        ctx.fillStyle = config.colors.secondary;
        ctx.beginPath();
        ctx.arc(0, 0, 8, 0, Math.PI * 2);
        ctx.fill();
        
      } else if (shipType === 'interceptor') {
        // Solar Interceptor - Sleek design
        ctx.fillStyle = config.colors.primary;
        ctx.beginPath();
        ctx.moveTo(25, 0);
        ctx.lineTo(-18, -8);
        ctx.lineTo(-12, -4);
        ctx.lineTo(-12, 4);
        ctx.lineTo(-18, 8);
        ctx.closePath();
        ctx.fill();
        
        ctx.fillStyle = config.colors.secondary;
        ctx.beginPath();
        ctx.moveTo(20, -2);
        ctx.lineTo(15, 0);
        ctx.lineTo(20, 2);
        ctx.closePath();
        ctx.fill();
      }
      
      // Cockpit
      ctx.fillStyle = config.colors.accent;
      ctx.beginPath();
      ctx.arc(3, 0, 3, 0, Math.PI * 2);
      ctx.fill();
      
      ctx.restore();
    }

    // Customization event listeners
    document.getElementById('start-game-btn').addEventListener('click', hideCustomizationScreen);
    document.getElementById('back-to-difficulty-btn').addEventListener('click', () => {
      customizationScreen.style.display = 'none';
      showDifficultyScreen();
    });

    // Heart system functions
    function createHearts() {
      const container = document.getElementById('hearts-container');
      if (!container) return;
      
      container.innerHTML = '';
      
      for (let i = 0; i < maxLives; i++) {
        const heart = document.createElement('div');
        heart.className = 'hexagon-heart';
        heart.id = `heart-${i}`;
        
        if (i < currentLives) {
          heart.classList.add('filled');
        } else {
          heart.classList.add('empty');
        }
        
        container.appendChild(heart);
      }
    }

    function setLives(newLives, animated = true) {
      const oldLives = currentLives;
      currentLives = Math.max(0, Math.min(maxLives, newLives));
      lives = currentLives;
      
      if (!animated) {
        createHearts();
        return;
      }
      
      if (currentLives < oldLives) {
        // Damage animation
        for (let i = 0; i < maxLives; i++) {
          const heart = document.getElementById(`heart-${i}`);
          if (heart) {
            heart.classList.add('damage-animation');
            setTimeout(() => {
              heart.classList.remove('damage-animation');
            }, 600);
          }
        }
        
        for (let i = oldLives - 1; i >= currentLives; i--) {
          const heart = document.getElementById(`heart-${i}`);
          if (heart) {
            heart.classList.add('losing-life');
            setTimeout(() => {
              heart.classList.remove('losing-life', 'filled');
              heart.classList.add('empty');
            }, 500);
          }
        }
      }
      
      if (currentLives > oldLives) {
        // Heal animation
        for (let i = oldLives; i < currentLives; i++) {
          const heart = document.getElementById(`heart-${i}`);
          if (heart) {
            heart.classList.add('heal-animation', 'gaining-life');
            setTimeout(() => {
              heart.classList.remove('gaining-life', 'empty');
              heart.classList.add('filled');
            }, 100);
            
            setTimeout(() => {
              heart.classList.remove('heal-animation');
              if (i >= 3) {
                heart.classList.add('powerup-glow');
                setTimeout(() => {
                  heart.classList.remove('powerup-glow');
                }, 800);
              }
            }, 800);
          }
        }
      }
    }

    // Canvas and responsiveness
    function resizeCanvas() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      if (ship) {
        ship.x = canvas.width / 2;
        ship.y = canvas.height / 2;
        if (!isMobile) {
          mouse.x = ship.x;
          mouse.y = ship.y;
        }
      }
      createStars();
    }

    window.addEventListener('resize', resizeCanvas);

    // Enhanced star generation
    let stars = [];
    function createStars() {
      stars = [];
      const starCount = Math.min(200, Math.floor((canvas.width * canvas.height) / 5000));
      for (let i = 0; i < starCount; i++) {
        stars.push({
          x: Math.random() * canvas.width,
          y: Math.random() * canvas.height,
          size: Math.random() * 3,
          speed: Math.random() * 0.8 + 0.2,
          twinkle: Math.random() * Math.PI * 2,
          color: Math.random() > 0.8 ? '#00ffff' : '#ffffff'
        });
      }
    }

    // Enhanced Particle class with improved performance
    class Particle {
      constructor(x, y, angle, speed, color = null, size = null, type = 'normal') {
        this.x = x;
        this.y = y;
        this.velX = Math.cos(angle) * speed;
        this.velY = Math.sin(angle) * speed;
        this.alpha = 1;
        this.size = size || Math.random() * 6 + 2;
        this.color = color || `hsl(${Math.random() * 60 + 10}, 100%, 50%)`;
        this.life = 1;
        this.decay = type === 'thruster' ? 0.015 : 0.02;
        this.gravity = type === 'thruster' ? 0.005 : 0.01;
        this.active = true;
        this.type = type;
        this.initialSize = this.size;
      }

      update() {
        if (!this.active) return;
        this.x += this.velX;
        this.y += this.velY;
        
        if (this.type === 'thruster') {
          this.velY += this.gravity * 0.5;
          this.velX *= 0.98;
          this.size = this.initialSize * this.life;
        } else {
          this.velY += this.gravity;
          this.size *= 0.98;
        }
        
        this.alpha -= this.decay;
        this.life -= this.decay;
        if (this.life <= 0) this.active = false;
      }

      draw() {
        if (!this.active) return;
        ctx.save();
        ctx.globalAlpha = this.alpha;
        ctx.fillStyle = this.color;
        
        if (this.type === 'thruster') {
          ctx.shadowBlur = 15;
          ctx.shadowColor = this.color;
        } else {
          ctx.shadowBlur = 10;
          ctx.shadowColor = this.color;
        }
        
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size / 2, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
      }
    }

    // Enhanced Explosion class
    class Explosion {
      constructor(x, y, size = 50) {
        this.x = x;
        this.y = y;
        this.size = size;
        this.maxSize = size;
        this.life = 1;
        this.particles = [];
        this.active = true;
        
        // Create explosion particles
        for (let i = 0; i < 15; i++) {
          const angle = (Math.PI * 2 * i) / 15;
          const speed = Math.random() * 8 + 4;
          this.particles.push(new Particle(x, y, angle, speed, '#ff4444', 8));
        }
      }

      update() {
        if (!this.active) return;
        this.life -= 0.05;
        this.size = this.maxSize * this.life;
        
        for (let i = this.particles.length - 1; i >= 0; i--) {
          this.particles[i].update();
          if (!this.particles[i].active) {
            this.particles.splice(i, 1);
          }
        }
        
        if (this.life <= 0) this.active = false;
      }

      draw() {
        if (!this.active) return;
        // Draw explosion ring
        ctx.save();
        ctx.globalAlpha = this.life;
        
        const gradient = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, this.size);
        gradient.addColorStop(0, 'rgba(255, 255, 255, 0.8)');
        gradient.addColorStop(0.4, 'rgba(255, 100, 100, 0.6)');
        gradient.addColorStop(1, 'rgba(255, 0, 0, 0)');
        
        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
        
        // Draw particles
        for (let particle of this.particles) {
          particle.draw();
        }
      }
    }

    // Enhanced Ship class with customization
    class Ship {
      constructor() {
        this.x = canvas.width / 2;
        this.y = canvas.height / 2;
        this.angle = 0;
        this.vel = { x: 0, y: 0 };
        this.radius = 20;
        this.doubleShot = false;
        this.doubleTimer = 0;
        this.lastShot = 0;
        this.shootCooldown = 150; // milliseconds
        this.active = true;
        this.thrusterParticles = [];
      }

      update() {
        if (!gameRunning || !this.active) return;

        let thrusting = false;
        const config = shipConfigs[selectedShip];

        if (!isMobile) {
          this.angle = Math.atan2(mouse.y - this.y, mouse.x - this.x);
          if (keys["w"] || keys["W"]) {
            this.vel.x += Math.cos(this.angle) * 0.3 * config.speedMultiplier;
            this.vel.y += Math.sin(this.angle) * 0.3 * config.speedMultiplier;
            thrusting = true;
          }
        } else {
          // Mobile joystick movement
          const joystickRect = joystick.getBoundingClientRect();
          const joystickContainerRect = joystickContainer.getBoundingClientRect();

          const joystickCenterX = joystickContainerRect.left + joystickContainerRect.width / 2;
          const joystickCenterY = joystickContainerRect.top + joystickContainerRect.height / 2;
          
          const currentJoystickX = joystickRect.left + joystickRect.width / 2;
          const currentJoystickY = joystickRect.top + joystickRect.height / 2;

          const dxJoy = currentJoystickX - joystickCenterX;
          const dyJoy = currentJoystickY - joystickCenterY;

          if (Math.hypot(dxJoy, dyJoy) > 10) { 
            this.angle = Math.atan2(dyJoy, dxJoy);
            // Reduced mobile speed: 0.18 instead of 0.3 (40% slower)
            this.vel.x += Math.cos(this.angle) * 0.18 * config.speedMultiplier;
            this.vel.y += Math.sin(this.angle) * 0.18 * config.speedMultiplier;
            thrusting = true;
          }
        }

        // Apply friction
        this.vel.x *= 0.95;
        this.vel.y *= 0.95;
        
        // Update position
        this.x += this.vel.x;
        this.y += this.vel.y;

        // Enhanced thruster particles
        if (thrusting) {
          for (let i = 0; i < 4; i++) {
            const offsetAngle = this.angle + Math.PI + (Math.random() - 0.5) * 0.6;
            const speed = Math.random() * 6 + 3;
            const distance = 25 + Math.random() * 15;
            const thrusterColor = this.getThrusterColor();
            
            particles.push(new Particle(
              this.x - Math.cos(this.angle) * distance,
              this.y - Math.sin(this.angle) * distance,
              offsetAngle,
              speed,
              thrusterColor,
              Math.random() * 4 + 2,
              'thruster'
            ));
          }
        }

        // Update stars parallax effect
        for (let star of stars) {
          star.x -= this.vel.x * star.speed * 0.5;
          star.y -= this.vel.y * star.speed * 0.5;
          star.twinkle += 0.1;
          
          if (star.x < -10) star.x = canvas.width + 10;
          if (star.x > canvas.width + 10) star.x = -10;
          if (star.y < -10) star.y = canvas.height + 10;
          if (star.y > canvas.height + 10) star.y = -10;
        }

        // Screen wrapping
        if (this.x < 0) this.x = canvas.width;
        if (this.x > canvas.width) this.x = 0;
        if (this.y < 0) this.y = canvas.height;
        if (this.y > canvas.height) this.y = 0;

        // Update power-ups
        if (this.doubleShot && this.doubleTimer > 0) {
          this.doubleTimer--;
        } else {
          this.doubleShot = false;
        }

        if (shieldActive && shieldTimer > 0) {
          shieldTimer--;
          shieldTimeSpan.textContent = Math.ceil(shieldTimer / 60);
        } else {
          shieldActive = false;
          shieldTimeSpan.textContent = 0;
        }
      }

      getThrusterColor() {
        const config = shipConfigs[selectedShip];
        const colors = [
          config.colors.primary,
          config.colors.secondary,
          '#ffaa00',
          '#ff6600'
        ];
        return colors[Math.floor(Math.random() * colors.length)];
      }

      draw() {
        if (!this.active) return;
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.angle);

        const config = shipConfigs[selectedShip];
        
        // Enhanced ship design based on selection
        ctx.shadowBlur = 15;
        ctx.shadowColor = config.colors.primary;
        
        drawShipPreview(ctx, 0, 0, selectedShip, 1);

        ctx.restore();

        // Enhanced shield effect
        if (shieldActive) {
          ctx.save();
          ctx.translate(this.x, this.y);
          
          const time = Date.now() * 0.008;
          const pulseFactor = Math.sin(time * 3) * 0.3 + 1;
          const shieldRadius = (this.radius + 15) * pulseFactor;
          
          // Multiple shield layers
          for (let i = 0; i < 3; i++) {
            const radius = shieldRadius - i * 5;
            const opacity = 0.4 - i * 0.1;
            
            const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, radius);
            gradient.addColorStop(0, `rgba(0, 200, 255, ${opacity * 0.2})`);
            gradient.addColorStop(0.8, `rgba(0, 150, 255, ${opacity * 0.6})`);
            gradient.addColorStop(1, `rgba(0, 100, 255, ${opacity})`);
            
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(0, 0, radius, 0, Math.PI * 2);
            ctx.fill();
          }
          
          // Hexagon pattern
          ctx.strokeStyle = `rgba(0, 255, 255, ${0.8 * pulseFactor})`;
          ctx.lineWidth = 2;
          
          const hexRadius = this.radius + 12;
          const rotationAngle = time * 0.5;
          
          for (let layer = 0; layer < 2; layer++) {
            const currentRadius = hexRadius + layer * 8;
            const currentRotation = rotationAngle + layer * 0.5;
            
            ctx.beginPath();
            for (let i = 0; i < 6; i++) {
              const angle = (i * Math.PI) / 3 + currentRotation;
              const x = Math.cos(angle) * currentRadius;
              const y = Math.sin(angle) * currentRadius;
              
              if (i === 0) {
                ctx.moveTo(x, y);
              } else {
                ctx.lineTo(x, y);
              }
            }
            ctx.closePath();
            ctx.stroke();
          }
          
          ctx.restore();
        }
      }

      canShoot() {
        const config = shipConfigs[selectedShip];
        const adjustedCooldown = this.shootCooldown / config.powerMultiplier;
        return Date.now() - this.lastShot > adjustedCooldown;
      }

      shoot() {
        if (!this.canShoot() || !this.active) return;
        
        this.lastShot = Date.now();
        bullets.push(new Bullet(this.x, this.y, this.angle, 'player'));
        
        if (this.doubleShot) {
          bullets.push(new Bullet(this.x, this.y, this.angle + 0.15, 'player'));
          bullets.push(new Bullet(this.x, this.y, this.angle - 0.15, 'player'));
        }
      }
    }

    // Enhanced Bullet class
    class Bullet {
      constructor(x, y, angle, owner = 'player') {
        this.x = x;
        this.y = y;
        this.angle = angle;
        this.owner = owner;
        this.speed = owner === 'player' ? 15 : 8;
        this.vel = {
          x: Math.cos(angle) * this.speed,
          y: Math.sin(angle) * this.speed
        };
        
        this.length = owner === 'player' ? 30 : 20;
        this.width = owner === 'player' ? 3 : 2;
        this.energy = 100;
        this.maxDistance = owner === 'player' ? 1000 : 800;
        this.distanceTraveled = 0;
        this.trail = [];
        this.maxTrailLength = owner === 'player' ? 8 : 5;
        this.glowIntensity = 1;
        this.active = true;
        
        // Enhanced damage based on ship config
        if (owner === 'player') {
          const config = shipConfigs[selectedShip];
          this.damage = Math.floor(10 * config.powerMultiplier);
        }
      }

      update() {
        if (!this.active) return;
        // Update position
        this.x += this.vel.x;
        this.y += this.vel.y;
        this.distanceTraveled += this.speed;
        
        // Add to trail
        this.trail.push({ x: this.x, y: this.y, intensity: this.glowIntensity });
        if (this.trail.length > this.maxTrailLength) {
          this.trail.shift();
        }
        
        // Fade out over distance
        this.energy = Math.max(0, 100 - (this.distanceTraveled / this.maxDistance) * 100);
        this.glowIntensity = this.energy / 100;
        
        // Create particle effects with ship colors
        if (Math.random() < 0.2) {
          const offsetAngle = this.angle + (Math.random() - 0.5) * 0.5;
          let color = this.owner === 'player' ? '#ff6666' : '#ffaa00';
          
          if (this.owner === 'player') {
            const config = shipConfigs[selectedShip];
            color = config.colors.primary;
          }
          
          particles.push(new Particle(
            this.x - Math.cos(this.angle) * 15,
            this.y - Math.sin(this.angle) * 15,
            offsetAngle,
            1,
            color,
            2
          ));
        }
        
        if (this.offscreen()) this.active = false;
      }

      draw() {
        if (!this.active || this.energy <= 0) return;
        
        ctx.save();
        
        // Draw trail
        for (let i = 0; i < this.trail.length; i++) {
          const point = this.trail[i];
          const trailAlpha = (i / this.trail.length) * this.glowIntensity * 0.5;
          const trailSize = (i / this.trail.length) * this.width;
          
          ctx.globalAlpha = trailAlpha;
          let trailColor = this.owner === 'player' ? '#ff8888' : '#ffcc88';
          
          if (this.owner === 'player') {
            const config = shipConfigs[selectedShip];
            trailColor = config.colors.secondary;
          }
          
          ctx.fillStyle = trailColor;
          ctx.beginPath();
          ctx.arc(point.x, point.y, trailSize, 0, Math.PI * 2);
          ctx.fill();
        }
        
        // Draw main bullet
        ctx.globalAlpha = this.glowIntensity;
        ctx.translate(this.x, this.y);
        ctx.rotate(this.angle);
        
        // Glow effect
        ctx.shadowBlur = 20;
        let shadowColor = this.owner === 'player' ? '#ff4444' : '#ffaa00';
        
        if (this.owner === 'player') {
          const config = shipConfigs[selectedShip];
          shadowColor = config.colors.primary;
        }
        
        ctx.shadowColor = shadowColor;
        
        // Main bullet body
        const gradient = ctx.createLinearGradient(-this.length/2, 0, this.length/2, 0);
        if (this.owner === 'player') {
          const config = shipConfigs[selectedShip];
          gradient.addColorStop(0, `${config.colors.secondary}40`);
          gradient.addColorStop(0.5, config.colors.accent);
          gradient.addColorStop(1, `${config.colors.primary}CC`);
        } else {
          gradient.addColorStop(0, 'rgba(255, 170, 0, 0.2)');
          gradient.addColorStop(0.5, 'rgba(255, 255, 100, 1)');
          gradient.addColorStop(1, 'rgba(255, 170, 0, 0.8)');
        }
        
        ctx.fillStyle = gradient;
        ctx.fillRect(-this.length/2, -this.width/2, this.length, this.width);
        
        // Core
        ctx.fillStyle = '#ffffff';
        ctx.fillRect(-this.length/2, -this.width/4, this.length, this.width/2);
        
        ctx.restore();
      }

      offscreen() {
        return this.energy <= 0 || 
               this.x < -100 || this.x > canvas.width + 100 ||
               this.y < -100 || this.y > canvas.height + 100;
      }
    }

    // Enhanced Boss Enemy class with balanced mechanics
    class Boss {
      constructor(type = 'destroyer') {
        this.type = type;
        this.x = canvas.width / 2;
        this.y = -100;
        this.targetY = canvas.height * 0.2;
        this.radius = 60;
        this.maxHealth = 200; // Increased health for better balance
        this.health = this.maxHealth;
        this.speed = 1;
        this.angle = 0;
        this.active = true;
        this.phase = 'entering';
        this.lastShot = 0;
        this.shootCooldown = 1200; // Slower shooting for balance
        this.lastSpecialAttack = 0;
        this.specialAttackCooldown = 4000; // Longer cooldown
        this.movePattern = 0;
        this.moveTimer = 0;
        this.pulsePhase = 0;
        this.damageReduction = 0.5; // Reduced damage from collision
        
        // Boss specific properties
        if (type === 'destroyer') {
          this.name = 'VOID DESTROYER';
          this.color1 = '#cc0000';
          this.color2 = '#880000';
          this.color3 = '#ff4444';
        }
      }

      update(target) {
        if (!this.active) return;
        
        this.pulsePhase += 0.05;
        
        if (this.phase === 'entering') {
          this.y += 2;
          if (this.y >= this.targetY) {
            this.phase = 'fighting';
          }
          return;
        }
        
        // Movement patterns
        this.moveTimer += 0.02;
        if (this.movePattern === 0) {
          this.x += Math.sin(this.moveTimer) * 2;
        } else if (this.movePattern === 1) {
          this.x += Math.cos(this.moveTimer * 0.7) * 3;
          this.y += Math.sin(this.moveTimer * 0.5) * 1;
        }
        
        // Change movement pattern occasionally
        if (Math.random() < 0.005) {
          this.movePattern = (this.movePattern + 1) % 2;
        }
        
        // Keep boss on screen
        this.x = Math.max(this.radius, Math.min(canvas.width - this.radius, this.x));
        this.y = Math.max(this.radius, Math.min(canvas.height * 0.4, this.y));
        
        // Update angle to face player
        this.angle = Math.atan2(target.y - this.y, target.x - this.x);
        
        // Regular shooting
        if (Date.now() - this.lastShot > this.shootCooldown) {
          this.shoot(target);
        }
        
        // Special attacks
        if (Date.now() - this.lastSpecialAttack > this.specialAttackCooldown) {
          this.specialAttack(target);
        }
        
        // Update health bar
        const healthPercent = (this.health / this.maxHealth) * 100;
        bossHealthFill.style.width = healthPercent + '%';
      }

      shoot(target) {
        this.lastShot = Date.now();
        
        // Single shot for better balance
        const bulletAngle = this.angle + (Math.random() - 0.5) * 0.2; // Add slight inaccuracy
        enemyBullets.push(new Bullet(this.x, this.y, bulletAngle, 'enemy'));
      }

      specialAttack(target) {
        this.lastSpecialAttack = Date.now();
        
        // Reduced spread shot for balance
        for (let i = 0; i < 5; i++) {
          const angle = (Math.PI * 2 * i) / 5;
          enemyBullets.push(new Bullet(this.x, this.y, angle, 'enemy'));
        }
      }

      takeDamage(amount, isShieldedHit = false) {
        // Reduced damage from shielded player collision
        const finalDamage = isShieldedHit ? amount * 0.3 : amount;
        this.health -= finalDamage;
        
        if (this.health <= 0) {
          this.active = false;
          return true; // Boss defeated
        }
        return false;
      }

      draw() {
        if (!this.active) return;
        
        ctx.save();
        ctx.translate(this.x, this.y);
        
        // Pulsing effect
        const pulse = Math.sin(this.pulsePhase) * 0.2 + 1;
        ctx.scale(pulse, pulse);
        
        // Main body
        ctx.shadowBlur = 25;
        ctx.shadowColor = this.color1;
        
        const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, this.radius);
        gradient.addColorStop(0, this.color3);
        gradient.addColorStop(0.6, this.color1);
        gradient.addColorStop(1, this.color2);
        
        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.arc(0, 0, this.radius, 0, Math.PI * 2);
        ctx.fill();
        
        // Boss details
        ctx.strokeStyle = this.color3;
        ctx.lineWidth = 4;
        
        // Cross pattern
        ctx.beginPath();
        ctx.moveTo(-this.radius * 0.7, 0);
        ctx.lineTo(this.radius * 0.7, 0);
        ctx.moveTo(0, -this.radius * 0.7);
        ctx.lineTo(0, this.radius * 0.7);
        ctx.stroke();
        
        // Outer spikes
        for (let i = 0; i < 8; i++) {
          const angle = (Math.PI * 2 * i) / 8;
          const innerRadius = this.radius * 0.8;
          const outerRadius = this.radius * 1.2;
          
          const x1 = Math.cos(angle) * innerRadius;
          const y1 = Math.sin(angle) * innerRadius;
          const x2 = Math.cos(angle) * outerRadius;
          const y2 = Math.sin(angle) * outerRadius;
          
          ctx.beginPath();
          ctx.moveTo(x1, y1);
          ctx.lineTo(x2, y2);
          ctx.stroke();
        }
        
        // Core
        ctx.fillStyle = '#ffffff';
        ctx.beginPath();
        ctx.arc(0, 0, this.radius * 0.3, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.restore();
      }
    }

    // Enhanced Enemy class with shooting capability
    class Enemy {
      constructor() {
        const edge = Math.floor(Math.random() * 4);
        const padding = 100;
        
        if (edge === 0) {
          this.x = Math.random() * canvas.width;
          this.y = -padding;
        } else if (edge === 1) {
          this.x = canvas.width + padding;
          this.y = Math.random() * canvas.height;
        } else if (edge === 2) {
          this.x = Math.random() * canvas.width;
          this.y = canvas.height + padding;
        } else {
          this.x = -padding;
          this.y = Math.random() * canvas.height;
        }
        
        this.radius = 18;
        this.speed = 1.5;
        this.health = 1;
        this.angle = 0;
        this.targetAngle = 0;
        this.angleSpeed = 0.05;
        this.active = true;
        
        // AI properties
        this.lastDirectionChange = 0;
        this.avoidanceRadius = 150;
        this.separationRadius = 80;
        this.cohesionRadius = 120;
        this.avoidanceStrength = 2;
        this.wanderAngle = Math.random() * Math.PI * 2;
        this.wanderSpeed = 0.02;
        
        // Shooting properties (for hard mode)
        this.lastShot = 0;
        this.shootCooldown = 2500 + Math.random() * 1000; // 2.5-3.5 seconds for balance
        this.shootRange = 250; // Reduced range
        
        // Visual properties
        this.pulsePhase = Math.random() * Math.PI * 2;
        this.trailPoints = [];
        this.maxTrailLength = 6;
      }

      update(target, allEnemies) {
        if (!this.active) return;
        
        // Calculate forces
        const toTarget = this.getVectorTo(target);
        const avoidanceBullets = this.avoidBullets();
        const separation = this.separate(allEnemies);
        const cohesion = this.cohesion(allEnemies);
        
        // Combine forces
        let forceX = toTarget.x * 0.3 + avoidanceBullets.x * 2 + separation.x * 1.5 + cohesion.x * 0.5;
        let forceY = toTarget.y * 0.3 + avoidanceBullets.y * 2 + separation.y * 1.5 + cohesion.y * 0.5;
        
        // Add wandering
        this.wanderAngle += (Math.random() - 0.5) * this.wanderSpeed;
        forceX += Math.cos(this.wanderAngle) * 0.2;
        forceY += Math.sin(this.wanderAngle) * 0.2;
        
        // Calculate target angle
        this.targetAngle = Math.atan2(forceY, forceX);
        
        // Smooth angle interpolation
        let angleDiff = this.targetAngle - this.angle;
        while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
        while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;
        
        this.angle += angleDiff * this.angleSpeed;
        
        // Update position
        this.x += Math.cos(this.angle) * this.speed;
        this.y += Math.sin(this.angle) * this.speed;
        
        // Update trail
        this.trailPoints.push({ x: this.x, y: this.y });
        if (this.trailPoints.length > this.maxTrailLength) {
          this.trailPoints.shift();
        }
        
        // Update pulse
        this.pulsePhase += 0.1;
        
        // Shooting logic for hard mode
        if (difficulty === 'hard' && target.active) {
          const distanceToTarget = Math.hypot(target.x - this.x, target.y - this.y);
          if (distanceToTarget < this.shootRange && Date.now() - this.lastShot > this.shootCooldown) {
            this.shoot(target);
          }
        }
      }

      shoot(target) {
        this.lastShot = Date.now();
        const angleToTarget = Math.atan2(target.y - this.y, target.x - this.x);
        
        // Add more inaccuracy for balance
        const inaccuracy = (Math.random() - 0.5) * 0.5;
        const finalAngle = angleToTarget + inaccuracy;
        
        enemyBullets.push(new Bullet(this.x, this.y, finalAngle, 'enemy'));
      }

      getVectorTo(target) {
        const dx = target.x - this.x;
        const dy = target.y - this.y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        return { x: dx / distance, y: dy / distance };
      }

      avoidBullets() {
        let avoidX = 0;
        let avoidY = 0;
        
        for (let bullet of bullets) {
          if (!bullet.active || bullet.owner !== 'player') continue;
          const dx = bullet.x - this.x;
          const dy = bullet.y - this.y;
          const distance = Math.sqrt(dx * dx + dy * dy);
          
          if (distance < this.avoidanceRadius && distance > 0) {
            const futureX = bullet.x + bullet.vel.x * 10;
            const futureY = bullet.y + bullet.vel.y * 10;
            const futureDistance = Math.sqrt((futureX - this.x) ** 2 + (futureY - this.y) ** 2);
            
            if (futureDistance < distance) {
              const force = (this.avoidanceRadius - distance) / this.avoidanceRadius;
              avoidX -= (dx / distance) * force;
              avoidY -= (dy / distance) * force;
            }
          }
        }
        
        return { x: avoidX, y: avoidY };
      }

      separate(enemies) {
        let separateX = 0;
        let separateY = 0;
        let count = 0;
        
        for (let enemy of enemies) {
          if (enemy === this || !enemy.active) continue;
          
          const dx = enemy.x - this.x;
          const dy = enemy.y - this.y;
          const distance = Math.sqrt(dx * dx + dy * dy);
          
          if (distance < this.separationRadius && distance > 0) {
            separateX -= dx / distance;
            separateY -= dy / distance;
            count++;
          }
        }
        
        if (count > 0) {
          separateX /= count;
          separateY /= count;
        }
        
        return { x: separateX, y: separateY };
      }

      cohesion(enemies) {
        let centerX = 0;
        let centerY = 0;
        let count = 0;
        
        for (let enemy of enemies) {
          if (enemy === this || !enemy.active) continue;
          
          const dx = enemy.x - this.x;
          const dy = enemy.y - this.y;
          const distance = Math.sqrt(dx * dx + dy * dy);
          
          if (distance < this.cohesionRadius) {
            centerX += enemy.x;
            centerY += enemy.y;
            count++;
          }
        }
        
        if (count > 0) {
          centerX /= count;
          centerY /= count;
          const dx = centerX - this.x;
          const dy = centerY - this.y;
          const distance = Math.sqrt(dx * dx + dy * dy);
          
          if (distance > 0) {
            return { x: dx / distance * 0.3, y: dy / distance * 0.3 };
          }
        }
        
        return { x: 0, y: 0 };
      }

      draw() {
        if (!this.active) return;
        ctx.save();
        
        // Draw trail
        for (let i = 0; i < this.trailPoints.length; i++) {
          const point = this.trailPoints[i];
          const alpha = (i / this.trailPoints.length) * 0.3;
          const size = (i / this.trailPoints.length) * this.radius * 0.5;
          
          ctx.globalAlpha = alpha;
          ctx.fillStyle = '#ff6666';
          ctx.beginPath();
          ctx.arc(point.x, point.y, size, 0, Math.PI * 2);
          ctx.fill();
        }
        
        // Draw main enemy
        ctx.globalAlpha = 1;
        ctx.translate(this.x, this.y);
        ctx.rotate(this.angle);
        
        // Pulsing glow
        const pulse = Math.sin(this.pulsePhase) * 0.3 + 0.7;
        ctx.shadowBlur = 15 * pulse;
        ctx.shadowColor = '#ff4444';
        
        // Main body
        const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, this.radius);
        gradient.addColorStop(0, '#ff8888');
        gradient.addColorStop(0.7, '#ff4444');
        gradient.addColorStop(1, '#cc0000');
        
        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.moveTo(this.radius, 0);
        ctx.lineTo(-this.radius * 0.8, -this.radius * 0.6);
        ctx.lineTo(-this.radius * 0.5, 0);
        ctx.lineTo(-this.radius * 0.8, this.radius * 0.6);
        ctx.closePath();
        ctx.fill();
        
        // Core
        ctx.fillStyle = '#ffffff';
        ctx.beginPath();
        ctx.arc(0, 0, this.radius * 0.3, 0, Math.PI * 2);
        ctx.fill();
        
        // Hard mode indicator (weapon glow)
        if (difficulty === 'hard') {
          ctx.fillStyle = '#ffaa00';
          ctx.shadowColor = '#ffaa00';
          ctx.shadowBlur = 8;
          ctx.beginPath();
          ctx.arc(this.radius * 0.6, 0, 3, 0, Math.PI * 2);
          ctx.fill();
        }
        
        ctx.restore();
      }
    }

    // Enhanced PowerUp class
    class PowerUp {
      constructor(type) {
        this.x = Math.random() * (canvas.width - 200) + 100;
        this.y = Math.random() * (canvas.height - 200) + 100;
        this.type = type;
        this.radius = 25;
        this.pulseTime = 0;
        this.glowIntensity = 0;
        this.floatOffset = Math.random() * Math.PI * 2;
        this.baseY = this.y;
        this.particles = [];
        this.active = true;
      }

      update() {
        if (!this.active) return;
        this.pulseTime += 0.08;
        this.glowIntensity = Math.sin(this.pulseTime) * 0.4 + 0.6;
        
        // Floating effect
        this.y = this.baseY + Math.sin(this.pulseTime * 2) * 5;
        
        // Create particles
        if (Math.random() < 0.2) {
          const angle = Math.random() * Math.PI * 2;
          const speed = Math.random() * 2 + 1;
          const color = this.getParticleColor();
          this.particles.push(new Particle(
            this.x + Math.cos(angle) * this.radius,
            this.y + Math.sin(angle) * this.radius,
            angle,
            speed,
            color,
            3
          ));
        }
        
        // Update particles
        for (let i = this.particles.length - 1; i >= 0; i--) {
          this.particles[i].update();
          if (!this.particles[i].active) {
            this.particles.splice(i, 1);
          }
        }
      }

      getParticleColor() {
        if (this.type === "life") return "#00ff88";
        if (this.type === "double") return "#ffdd00";
        if (this.type === "shield") return "#00aaff";
        return "#ffffff";
      }

      draw() {
        if (!this.active) return;
        // Draw particles
        for (let particle of this.particles) {
          particle.draw();
        }
        
        ctx.save();
        ctx.translate(this.x, this.y);
        
        // Enhanced glow effect
        ctx.shadowBlur = 25;
        ctx.shadowColor = this.getGlowColor();
        
        // Outer ring
        ctx.beginPath();
        ctx.arc(0, 0, this.radius + 4, 0, Math.PI * 2);
        ctx.fillStyle = this.getOuterRingColor();
        ctx.fill();
        
        // Main body with enhanced gradient
        const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, this.radius);
        gradient.addColorStop(0, this.getGradientCenter());
        gradient.addColorStop(0.6, this.getGradientMid());
        gradient.addColorStop(1, this.getGradientEdge());
        
        ctx.beginPath();
        ctx.arc(0, 0, this.radius, 0, Math.PI * 2);
        ctx.fillStyle = gradient;
        ctx.fill();
        
        // Inner glow
        ctx.shadowBlur = 0;
        ctx.fillStyle = `rgba(255, 255, 255, ${this.glowIntensity * 0.3})`;
        ctx.beginPath();
        ctx.arc(0, 0, this.radius * 0.7, 0, Math.PI * 2);
        ctx.fill();
        
        // Icon
        this.drawIcon();
        
        ctx.restore();
      }

      getGlowColor() {
        if (this.type === "life") return `rgba(0, 255, 136, ${this.glowIntensity})`;
        if (this.type === "double") return `rgba(255, 221, 0, ${this.glowIntensity})`;
        if (this.type === "shield") return `rgba(0, 170, 255, ${this.glowIntensity})`;
      }

      getOuterRingColor() {
        if (this.type === "life") return "#00AA88";
        if (this.type === "double") return "#CC9900";
        if (this.type === "shield") return "#0088CC";
      }

      getGradientCenter() {
        if (this.type === "life") return "#00FF88";
        if (this.type === "double") return "#FFDD00";
        if (this.type === "shield") return "#00AAFF";
      }

      getGradientMid() {
        if (this.type === "life") return "#00DD66";
        if (this.type === "double") return "#DDAA00";
        if (this.type === "shield") return "#0088DD";
      }

      getGradientEdge() {
        if (this.type === "life") return "#00BB44";
        if (this.type === "double") return "#BB8800";
        if (this.type === "shield") return "#0066BB";
      }

      drawIcon() {
        ctx.strokeStyle = "white";
        ctx.fillStyle = "white";
        ctx.lineWidth = 3;
        ctx.lineCap = "round";
        ctx.lineJoin = "round";
        
        if (this.type === "life") {
          // Enhanced plus icon
          ctx.shadowBlur = 10;
          ctx.shadowColor = "white";
          ctx.beginPath();
          ctx.rect(-3, -10, 6, 20);
          ctx.fill();
          ctx.beginPath();
          ctx.rect(-10, -3, 20, 6);
          ctx.fill();
          
        } else if (this.type === "double") {
          // Enhanced multi-shot icon
          ctx.shadowBlur = 8;
          ctx.shadowColor = "white";
          
          // Draw arrows
          for (let i = 0; i < 3; i++) {
            const offsetY = (i - 1) * 8;
            ctx.beginPath();
            ctx.moveTo(-12, offsetY);
            ctx.lineTo(8, offsetY);
            ctx.moveTo(8, offsetY);
            ctx.lineTo(4, offsetY - 4);
            ctx.moveTo(8, offsetY);
            ctx.lineTo(4, offsetY + 4);
            ctx.stroke();
          }
          
        } else if (this.type === "shield") {
          // Enhanced shield icon
          ctx.shadowBlur = 10;
          ctx.shadowColor = "white";
          ctx.beginPath();
          ctx.moveTo(0, -12);
          ctx.lineTo(-10, -8);
          ctx.lineTo(-10, 4);
          ctx.lineTo(-5, 8);
          ctx.lineTo(0, 12);
          ctx.lineTo(5, 8);
          ctx.lineTo(10, 4);
          ctx.lineTo(10, -8);
          ctx.closePath();
          ctx.fill();
          
          // Shield details
          ctx.strokeStyle = "#0066BB";
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.moveTo(0, -8);
          ctx.lineTo(0, 8);
          ctx.moveTo(-6, -4);
          ctx.lineTo(6, -4);
          ctx.moveTo(-4, 2);
          ctx.lineTo(4, 2);
          ctx.stroke();
        }
      }
    }

    // Boss warning function
    function showBossWarning() {
      bossWarning.style.display = 'flex';
      setTimeout(() => {
        bossWarning.style.display = 'none';
      }, 2000);
    }

    // Game objects
    const ship = new Ship();
    const bullets = [];
    const enemies = [];

    // Game loop variables
    let spawnTimer = 0;
    let powerTimer = 0;
    let enemySpawnRate = 180;
    let waveLevel = 1;

    function initGame() {
      gameRunning = true;
      lives = 3;
      currentLives = 3;
      score = 0;
      shieldActive = false;
      shieldTimer = 0;
      enemySpawnRate = 180;
      waveLevel = 1;
      enemiesKilled = 0;
      nextBossAt = 20;
      bossActive = false;
      currentBoss = null;

      scoreSpan.textContent = score;
      shieldTimeSpan.textContent = 0;
      gameOverScreen.style.display = "none";
      bossHealthContainer.style.display = "none";

      // Clear arrays
      bullets.length = 0;
      enemies.length = 0;
      powerUps.length = 0;
      particles.length = 0;
      explosions.length = 0;
      enemyBullets.length = 0;

      // Reset ship
      ship.x = canvas.width / 2;
      ship.y = canvas.height / 2;
      ship.vel.x = 0;
      ship.vel.y = 0;
      ship.doubleShot = false;
      ship.doubleTimer = 0;
      ship.active = true;

      // Reset mobile controls
      if (isMobile) {
        resetJoystick();
      } else {
        mouse.x = ship.x;
        mouse.y = ship.y;
      }

      createStars();
      createHearts();

      if (animationFrameId) {
        cancelAnimationFrame(animationFrameId);
      }
      animationFrameId = requestAnimationFrame(gameLoop);
    }

    function gameOver() {
      gameRunning = false;
      ship.active = false;
      bossActive = false;
      currentBoss = null;
      fullscreenManager.hide();
      if (animationFrameId) {
        cancelAnimationFrame(animationFrameId);
      }
      finalScoreSpan.textContent = score;
      gameOverScreen.style.display = "flex";
      bossHealthContainer.style.display = "none";
      
      // Create explosion at ship position
      explosions.push(new Explosion(ship.x, ship.y, 80));
    }

    function spawnBoss() {
      if (bossActive) return;
      
      showBossWarning();
      bossActive = true;
      
      setTimeout(() => {
        currentBoss = new Boss('destroyer');
        bossName.textContent = currentBoss.name;
        bossHealthContainer.style.display = 'block';
        
        // Clear regular enemies
        for (let enemy of enemies) {
          enemy.active = false;
        }
      }, 2000);
    }

    function gameLoop() {
      if (!gameRunning) return;

      // Clear canvas with gradient background
      const gradient = ctx.createRadialGradient(canvas.width/2, canvas.height/2, 0, canvas.width/2, canvas.height/2, Math.max(canvas.width, canvas.height)/2);
      gradient.addColorStop(0, '#1a1a3e');
      gradient.addColorStop(1, '#000000');
      ctx.fillStyle = gradient;
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      // Draw enhanced stars
      for (let star of stars) {
        const twinkle = Math.sin(star.twinkle) * 0.3 + 0.7;
        ctx.fillStyle = star.color;
        ctx.globalAlpha = twinkle;
        ctx.shadowBlur = star.size * 2;
        ctx.shadowColor = star.color;
        ctx.fillRect(star.x, star.y, star.size, star.size);
        ctx.globalAlpha = 1;
        ctx.shadowBlur = 0;
      }

      // Update and draw particles (optimized)
      for (let i = particles.length - 1; i >= 0; i--) {
        const p = particles[i];
        p.update();
        if (!p.active) {
          particles.splice(i, 1);
        } else {
          p.draw();
        }
      }

      // Update and draw explosions
      for (let i = explosions.length - 1; i >= 0; i--) {
        const e = explosions[i];
        e.update();
        e.draw();
        if (!e.active) {
          explosions.splice(i, 1);
        }
      }

      // Update ship
      ship.update();
      ship.draw();

      // Check for boss spawn
      if (enemiesKilled >= nextBossAt && !bossActive) {
        spawnBoss();
        nextBossAt += 20;
      }

      // Update boss with balanced mechanics
      if (currentBoss && currentBoss.active) {
        currentBoss.update(ship);
        currentBoss.draw();
        
        // Check collision with player bullets
        for (let j = bullets.length - 1; j >= 0; j--) {
          const b = bullets[j];
          if (!b.active || b.owner !== 'player') continue;
          const bdx = currentBoss.x - b.x;
          const bdy = currentBoss.y - b.y;
          if (Math.hypot(bdx, bdy) < currentBoss.radius + b.width) {
            // Damage boss
            const defeated = currentBoss.takeDamage(b.damage || 10);
            explosions.push(new Explosion(b.x, b.y, 20));
            b.active = false;
            
            if (defeated) {
              // Boss defeated
              explosions.push(new Explosion(currentBoss.x, currentBoss.y, 100));
              score += 500; // Bonus points for boss
              scoreSpan.textContent = score;
              bossActive = false;
              currentBoss = null;
              bossHealthContainer.style.display = 'none';
              
              // Spawn special power-up
              powerUps.push(new PowerUp(['life', 'shield', 'double'][Math.floor(Math.random() * 3)]));
            }
            break;
          }
        }
        
        // Enhanced boss collision mechanics
        if (ship.active) {
          const dx = currentBoss.x - ship.x;
          const dy = currentBoss.y - ship.y;
          const dist = Math.hypot(dx, dy);
          if (dist < currentBoss.radius + ship.radius) {
            if (shieldActive) {
              // Reduced damage to boss with shield collision
              const defeated = currentBoss.takeDamage(15, true); // Reduced damage, marked as shielded hit
              explosions.push(new Explosion(currentBoss.x, currentBoss.y, 30));
              if (defeated) {
                score += 500;
                scoreSpan.textContent = score;
                bossActive = false;
                currentBoss = null;
                bossHealthContainer.style.display = 'none';
              }
            } else {
              // Balanced player damage from boss collision
              explosions.push(new Explosion(ship.x, ship.y, 50));
              setLives(lives - 1); // Reduced from 2 damage to 1 for better balance
              if (lives <= 0) {
                gameOver();
                return;
              }
            }
          }
        }
      }

      // Spawn regular enemies (not when boss is active)
      if (!bossActive) {
        if (spawnTimer >= enemySpawnRate) {
          enemies.push(new Enemy());
          spawnTimer = 0;
          
          // Increase difficulty
          if (enemySpawnRate > 60) {
            enemySpawnRate -= 0.5;
          }
          
          // Wave progression
          if (enemiesKilled > 0 && enemiesKilled % 10 === 0) {
            waveLevel++;
            enemySpawnRate = Math.max(60, 180 - waveLevel * 15);
          }
        } else {
          spawnTimer++;
        }
      }

      // Update enemies
      for (let i = enemies.length - 1; i >= 0; i--) {
        const e = enemies[i];
        if (!e.active) {
          enemies.splice(i, 1);
          continue;
        }
        
        e.update(ship, enemies);
        e.draw();
        
        // Check collision with ship
        if (ship.active) {
          const dx = e.x - ship.x;
          const dy = e.y - ship.y;
          const dist = Math.hypot(dx, dy);
          if (dist < e.radius + ship.radius) {
            if (shieldActive) {
              // Destroy enemy if shield is active
              explosions.push(new Explosion(e.x, e.y, 40));
              e.active = false;
              score += 2; // Bonus points for shield kill
              scoreSpan.textContent = score;
            } else {
              // Damage player
              explosions.push(new Explosion(e.x, e.y, 50));
              e.active = false;
              setLives(lives - 1);
              if (lives <= 0) {
                gameOver();
                return;
              }
            }
            continue;
          }
        }

        // Check collision with player bullets
        for (let j = bullets.length - 1; j >= 0; j--) {
          const b = bullets[j];
          if (!b.active || b.owner !== 'player') continue;
          const bdx = e.x - b.x;
          const bdy = e.y - b.y;
          if (Math.hypot(bdx, bdy) < e.radius + b.width) {
            // Create explosion
            explosions.push(new Explosion(e.x, e.y, 30));
            
            // Remove enemy and bullet
            e.active = false;
            b.active = false;
            
            // Increase score
            score += 10;
            enemiesKilled++;
            scoreSpan.textContent = score;
            break;
          }
        }
      }

      // Update enemy bullets (hard mode and boss)
      if (difficulty === 'hard' || bossActive) {
        for (let i = enemyBullets.length - 1; i >= 0; i--) {
          const b = enemyBullets[i];
          if (!b.active) {
            enemyBullets.splice(i, 1);
            continue;
          }
          
          b.update();
          b.draw();
          
          if (b.offscreen()) {
            b.active = false;
            continue;
          }
          
          // Check collision with ship
          if (ship.active) {
            const dx = ship.x - b.x;
            const dy = ship.y - b.y;
            if (Math.hypot(dx, dy) < ship.radius + b.width) {
              if (shieldActive) {
                // Bullet destroyed by shield
                explosions.push(new Explosion(b.x, b.y, 20));
                b.active = false;
              } else {
                // Damage player
                explosions.push(new Explosion(b.x, b.y, 25));
                b.active = false;
                setLives(lives - 1);
                if (lives <= 0) {
                  gameOver();
                  return;
                }
              }
            }
          }
        }
      }

      // Spawn power-ups
      powerTimer++;
      if (powerTimer > 900) { // Every 15 seconds at 60fps
        const types = ["life", "double", "shield"];
        const type = types[Math.floor(Math.random() * types.length)];
        powerUps.push(new PowerUp(type));
        powerTimer = 0;
      }

      // Update power-ups
      for (let i = powerUps.length - 1; i >= 0; i--) {
        const p = powerUps[i];
        if (!p.active) {
          powerUps.splice(i, 1);
          continue;
        }
        
        p.update();
        p.draw();
        
        if (ship.active) {
          const dx = p.x - ship.x;
          const dy = p.y - ship.y;
          if (Math.hypot(dx, dy) < p.radius + ship.radius) {
            if (p.type === "life") {
              setLives(Math.min(maxLives, lives + 1));
            } else if (p.type === "double") {
              ship.doubleShot = true;
              ship.doubleTimer = 900; // 15 seconds
            } else if (p.type === "shield") {
              shieldActive = true;
              shieldTimer = 600; // 10 seconds
              shieldTimeSpan.textContent = Math.ceil(shieldTimer / 60);
            }
            
            // Create pickup effect
            for (let j = 0; j < 10; j++) {
              const angle = (Math.PI * 2 * j) / 10;
              particles.push(new Particle(p.x, p.y, angle, 3, p.getParticleColor(), 5));
            }
            
            p.active = false;
          }
        }
      }

      // Update bullets
      for (let i = bullets.length - 1; i >= 0; i--) {
        const b = bullets[i];
        if (!b.active) {
          bullets.splice(i, 1);
          continue;
        }
        b.update();
        b.draw();
        if (b.offscreen()) {
          b.active = false;
        }
      }

      animationFrameId = requestAnimationFrame(gameLoop);
    }

    // Controls
    function fireBullet() {
      ship.shoot();
    }

    // PC Controls
    document.addEventListener("mousemove", e => {
      if (!isMobile && gameRunning) {
        mouse.x = e.clientX;
        mouse.y = e.clientY;
      }
    });

    document.addEventListener("keydown", e => {
      if (!isMobile && gameRunning) {
        keys[e.key.toLowerCase()] = true;
        if (e.key === ' ' || e.key === 'Enter') {
          e.preventDefault();
          fireBullet();
        }
      }
    });

    document.addEventListener("keyup", e => {
      if (!isMobile && gameRunning) {
        keys[e.key.toLowerCase()] = false;
      }
    });

    document.addEventListener("mousedown", e => {
      if (!isMobile && e.button === 0 && gameRunning) {
        fireBullet();
      }
    });

    // Enhanced Mobile Controls with better performance
    let joystickActive = false;
    let joystickTouchId = null;
    let shootingInterval = null;
    let joystickCenter = { x: 0, y: 0 };
    let maxJoystickDistance = 0;

    function resetJoystick() {
      joystick.style.left = `calc(50% - ${joystick.clientWidth / 2}px)`;
      joystick.style.top = `calc(50% - ${joystick.clientHeight / 2}px)`;
      joystick.classList.remove('active');
      joystickActive = false;
      joystickTouchId = null;
    }

    function updateJoystickCenter() {
      const containerRect = joystickContainer.getBoundingClientRect();
      joystickCenter.x = containerRect.left + containerRect.width / 2;
      joystickCenter.y = containerRect.top + containerRect.height / 2;
      maxJoystickDistance = (containerRect.width / 2) - (joystick.clientWidth / 2) - 5;
    }

    if (isMobile) {
      mobileControlsDiv.style.display = "flex";

      // Update joystick center on resize
      window.addEventListener('resize', updateJoystickCenter);
      updateJoystickCenter();

      // Optimized touch events with passive listeners where possible
      joystickContainer.addEventListener("touchstart", (e) => {
        if (!gameRunning || joystickTouchId !== null) return;
        e.preventDefault();
        
        const touch = e.changedTouches[0];
        joystickTouchId = touch.identifier;
        joystickActive = true;
        joystick.classList.add('active');
        
        updateJoystickCenter();
      }, { passive: false });

      // Improved shoot button with better feedback
      shootButton.addEventListener("touchstart", (e) => {
        if (!gameRunning) return;
        e.preventDefault();
        shootButton.classList.add('active');
        fireBullet();
        
        // Optimized shooting interval
        shootingInterval = setInterval(() => {
          if (gameRunning) {
            fireBullet();
          }
        }, 120); // Faster shooting on mobile
      }, { passive: false });

      shootButton.addEventListener("touchend", (e) => {
        e.preventDefault();
        shootButton.classList.remove('active');
        if (shootingInterval) {
          clearInterval(shootingInterval);
          shootingInterval = null;
        }
      }, { passive: false });

      // Optimized global touch move
      document.addEventListener("touchmove", (e) => {
        if (!gameRunning || joystickTouchId === null) return;
        e.preventDefault();

        for (let i = 0; i < e.changedTouches.length; i++) {
          const touch = e.changedTouches[i];
          if (touch.identifier === joystickTouchId) {
            let deltaX = touch.clientX - joystickCenter.x;
            let deltaY = touch.clientY - joystickCenter.y;

            const distance = Math.hypot(deltaX, deltaY);
            
            if (distance > maxJoystickDistance) {
              const angle = Math.atan2(deltaY, deltaX);
              deltaX = Math.cos(angle) * maxJoystickDistance;
              deltaY = Math.sin(angle) * maxJoystickDistance;
            }

            // Use transform for better performance
            joystick.style.transform = `translate(${deltaX}px, ${deltaY}px)`;
            break;
          }
        }
      }, { passive: false });

      // Global touch end
      document.addEventListener("touchend", (e) => {
        if (!gameRunning) return;

        for (let i = 0; i < e.changedTouches.length; i++) {
          const touch = e.changedTouches[i];
          if (touch.identifier === joystickTouchId) {
            resetJoystick();
            break;
          }
        }
        
        if (shootingInterval) {
          clearInterval(shootingInterval);
          shootingInterval = null;
        }
        shootButton.classList.remove('active');
      }, { passive: false });

      // Touch cancel
      document.addEventListener("touchcancel", (e) => {
        resetJoystick();
        if (shootingInterval) {
          clearInterval(shootingInterval);
          shootingInterval = null;
        }
        shootButton.classList.remove('active');
      }, { passive: false });

    } else {
      mobileControlsDiv.style.display = "none";
    }

    // Enhanced reset joystick function
    function resetJoystick() {
      joystick.style.transform = 'translate(0px, 0px)';
      joystick.style.left = `calc(50% - ${joystick.clientWidth / 2}px)`;
      joystick.style.top = `calc(50% - ${joystick.clientHeight / 2}px)`;
      joystick.classList.remove('active');
      joystickActive = false;
      joystickTouchId = null;
    }

    // Restart and difficulty buttons
    restartButton.addEventListener("click", () => {
      fullscreenManager.show();
      resizeCanvas();
      initGame();
      // Auto-enter fullscreen on restart
      setTimeout(() => {
        fullscreenManager.autoEnterFullscreen();
      }, 500);
    });

    customizeButton.addEventListener("click", () => {
      gameOverScreen.style.display = "none";
      fullscreenManager.hide();
      showCustomizationScreen();
    });

    difficultyButton.addEventListener("click", () => {
      gameOverScreen.style.display = "none";
      fullscreenManager.hide();
      showDifficultyScreen();
    });

    // Initialize
    resizeCanvas();
    // Game will be initialized after customization
  </script>
</body>
</html>
