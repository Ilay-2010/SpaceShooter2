<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Space Shooter - Enhanced Edition</title>
  <!-- Enhanced mobile viewport settings for iOS -->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
  <!-- iOS-specific meta tags -->
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-fullscreen">
  <meta name="apple-touch-fullscreen" content="yes">
  <meta name="format-detection" content="telephone=no">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
  <link rel="icon" href="icon.png" type="image/x-icon">
  <style>
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: radial-gradient(circle at center, #0a0a2e, #000);
      touch-action: manipulation;
      height: 100%;
      width: 100%;
      font-family: 'Orbitron', 'Arial', sans-serif;
      /* Enhanced text selection prevention for iOS */
      -webkit-user-select: none;
      -moz-user-select: none;
      -ms-user-select: none;
      user-select: none;
      -webkit-touch-callout: none;
      -webkit-tap-highlight-color: transparent;
      /* iOS performance optimizations */
      -webkit-transform: translateZ(0);
      -webkit-backface-visibility: hidden;
      -webkit-perspective: 1000;
    }

    @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap');

    canvas {
      display: block;
      background: linear-gradient(45deg, #0a0a2e, #16213e, #0a0a2e);
      /* Enhanced canvas optimization for iOS */
      -webkit-user-select: none;
      -moz-user-select: none;
      -ms-user-select: none;
      user-select: none;
      -webkit-transform: translateZ(0);
      -webkit-backface-visibility: hidden;
      /* Hardware acceleration for mobile */
      transform: translateZ(0);
      backface-visibility: hidden;
    }

    /* Enhanced global selection prevention for iOS */
    * {
      -webkit-user-select: none;
      -moz-user-select: none;
      -ms-user-select: none;
      user-select: none;
      -webkit-touch-callout: none;
      /* iOS performance optimizations */
      -webkit-transform: translateZ(0);
      box-sizing: border-box;
    }

    /* Allow selection only for specific elements if needed */
    input, textarea {
      -webkit-user-select: text;
      -moz-user-select: text;
      -ms-user-select: text;
      user-select: text;
    }

    /* Hexagon Hearts Styles */
    .health-container {
      display: flex;
      align-items: center;
      gap: 12px;
      font-size: 28px;
      font-weight: bold;
      text-shadow: 2px 2px 4px black;
    }

    .hearts-container {
      display: flex;
      gap: 4px;
    }

    .hexagon-heart {
      width: 24px;
      height: 24px;
      position: relative;
      margin: 2px;
    }

    .hexagon-heart::before {
      content: '';
      position: absolute;
      width: 24px;
      height: 24px;
      background: transparent;
      border: 2px solid #ff6b6b;
      transform: rotate(45deg);
      transition: all 0.3s ease;
    }

    .hexagon-heart::after {
      content: '';
      position: absolute;
      width: 17px;
      height: 17px;
      background: transparent;
      border: 2px solid #ff6b6b;
      transform: rotate(45deg);
      top: 3.5px;
      left: 3.5px;
      transition: all 0.3s ease;
    }

    .hexagon-heart.filled::before {
      background: #ff6b6b;
      border-color: #ff6b6b;
      box-shadow: 0 0 12px rgba(255, 107, 107, 0.8);
    }

    .hexagon-heart.filled::after {
      background: #ff4444;
      border-color: #ff4444;
    }

    .hexagon-heart.empty::before,
    .hexagon-heart.empty::after {
      background: transparent;
      border-color: rgba(255, 107, 107, 0.3);
      animation: pulse-empty 2s infinite;
    }

    @keyframes pulse-empty {
      0%, 100% { opacity: 0.3; }
      50% { opacity: 0.6; }
    }

    .hexagon-heart.damage-animation {
      animation: damage-shake 0.6s ease-in-out;
    }

    @keyframes damage-shake {
      0%, 100% { transform: translateX(0); }
      10%, 30%, 50%, 70%, 90% { transform: translateX(-3px); }
      20%, 40%, 60%, 80% { transform: translateX(3px); }
    }

    .hexagon-heart.losing-life::before,
    .hexagon-heart.losing-life::after {
      animation: fade-out 0.5s ease-out forwards;
    }

    @keyframes fade-out {
      0% { 
        background: #ff6b6b;
        box-shadow: 0 0 12px rgba(255, 107, 107, 0.8);
        opacity: 1;
        transform: rotate(45deg) scale(1);
      }
      50% {
        transform: rotate(45deg) scale(1.2);
        opacity: 0.5;
      }
      100% { 
        background: transparent;
        box-shadow: none;
        opacity: 0.3;
        transform: rotate(45deg) scale(1);
      }
    }

    .hexagon-heart.heal-animation {
      animation: heal-pulse 0.8s ease-in-out;
    }

    @keyframes heal-pulse {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.3); }
    }

    .hexagon-heart.gaining-life::before,
    .hexagon-heart.gaining-life::after {
      animation: fade-in 0.6s ease-out forwards;
    }

    @keyframes fade-in {
      0% { 
        background: transparent;
        box-shadow: none;
        opacity: 0.3;
        transform: rotate(45deg) scale(0.5);
      }
      50% {
        transform: rotate(45deg) scale(1.2);
        opacity: 0.8;
      }
      100% { 
        background: #ff6b6b;
        box-shadow: 0 0 12px rgba(255, 107, 107, 0.8);
        opacity: 1;
        transform: rotate(45deg) scale(1);
      }
    }

    .hexagon-heart.powerup-glow::before {
      animation: powerup-glow 0.8s ease-in-out;
    }

    @keyframes powerup-glow {
      0%, 100% { box-shadow: 0 0 12px rgba(255, 107, 107, 0.8); }
      50% { box-shadow: 0 0 25px rgba(255, 215, 0, 1), 0 0 35px rgba(255, 107, 107, 0.8); }
    }

    /* Enhanced HUD */
    #hud {
      position: absolute;
      top: 20px;
      left: 20px;
      color: white;
      font-family: 'Orbitron', sans-serif;
      font-size: 18px;
      font-weight: 700;
      z-index: 10;
      text-shadow: 0 0 10px rgba(0, 255, 255, 0.7);
      background: rgba(0, 0, 0, 0.3);
      padding: 15px;
      border-radius: 10px;
      border: 1px solid rgba(0, 255, 255, 0.3);
      backdrop-filter: blur(5px);
      -webkit-backdrop-filter: blur(5px);
    }

    .hud-item {
      margin-bottom: 8px;
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .hud-label {
      color: #00ffff;
      text-shadow: 0 0 5px rgba(0, 255, 255, 0.5);
    }

    .hud-value {
      color: #ffffff;
      font-weight: 900;
    }

    .difficulty-indicator {
      color: #ffaa00;
      font-size: 14px;
      text-shadow: 0 0 5px rgba(255, 170, 0, 0.8);
    }

    .difficulty-medium {
      color: #ff8800;
      text-shadow: 0 0 5px rgba(255, 136, 0, 0.8);
    }

    .difficulty-hard {
      color: #ff4444;
      text-shadow: 0 0 5px rgba(255, 68, 68, 0.8);
    }

    /* High Score Display */
    .high-score {
      color: #ffd700;
      text-shadow: 0 0 8px rgba(255, 215, 0, 0.8);
    }

    /* Boss Health Bar */
    #boss-health-container {
      position: absolute;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      width: 400px;
      display: none;
      z-index: 15;
    }

    .boss-health-bar {
      width: 100%;
      height: 20px;
      background: rgba(0, 0, 0, 0.7);
      border: 2px solid #ff4444;
      border-radius: 10px;
      overflow: hidden;
      position: relative;
    }

    .boss-health-fill {
      height: 100%;
      background: linear-gradient(90deg, #ff4444, #ffaa00, #ff4444);
      width: 100%;
      transition: width 0.3s ease;
      box-shadow: 0 0 15px rgba(255, 68, 68, 0.8);
    }

    .boss-name {
      text-align: center;
      color: #ff4444;
      font-family: 'Orbitron', sans-serif;
      font-weight: 900;
      font-size: 16px;
      margin-bottom: 5px;
      text-shadow: 0 0 10px rgba(255, 68, 68, 1);
      animation: boss-name-glow 2s ease-in-out infinite alternate;
    }

    @keyframes boss-name-glow {
      0% { text-shadow: 0 0 10px rgba(255, 68, 68, 1); }
      100% { text-shadow: 0 0 20px rgba(255, 68, 68, 1), 0 0 30px rgba(255, 68, 68, 0.5); }
    }

    /* Control Buttons Container */
    #control-buttons {
      position: absolute;
      top: 20px;
      right: 20px;
      display: flex;
      flex-direction: column;
      gap: 10px;
      z-index: 20;
    }

    /* Fullscreen Button */
    #fullscreen-btn {
      background: rgba(0, 255, 255, 0.2);
      border: 2px solid rgba(0, 255, 255, 0.5);
      color: #00ffff;
      padding: 10px 15px;
      border-radius: 8px;
      font-family: 'Orbitron', sans-serif;
      font-weight: 700;
      cursor: pointer;
      backdrop-filter: blur(5px);
      -webkit-backdrop-filter: blur(5px);
      transition: all 0.3s ease;
    }

    #fullscreen-btn:hover {
      background: rgba(0, 255, 255, 0.3);
      border-color: rgba(0, 255, 255, 0.8);
      transform: translateY(-2px);
    }

    /* Pause Button */
    #pause-btn {
      background: rgba(255, 255, 0, 0.2);
      border: 2px solid rgba(255, 255, 0, 0.5);
      color: #ffff00;
      padding: 10px 15px;
      border-radius: 8px;
      font-family: 'Orbitron', sans-serif;
      font-weight: 700;
      cursor: pointer;
      backdrop-filter: blur(5px);
      -webkit-backdrop-filter: blur(5px);
      transition: all 0.3s ease;
      display: none;
    }

    #pause-btn:hover {
      background: rgba(255, 255, 0, 0.3);
      border-color: rgba(255, 255, 0, 0.8);
      transform: translateY(-2px);
    }

    #pause-btn.paused {
      background: rgba(255, 0, 0, 0.2);
      border-color: rgba(255, 0, 0, 0.5);
      color: #ff0000;
    }

    #pause-btn.paused:hover {
      background: rgba(255, 0, 0, 0.3);
      border-color: rgba(255, 0, 0, 0.8);
    }

    /* Audio Button */
    #audio-btn {
      background: rgba(0, 255, 0, 0.2);
      border: 2px solid rgba(0, 255, 0, 0.5);
      color: #00ff00;
      padding: 10px 15px;
      border-radius: 8px;
      font-family: 'Orbitron', sans-serif;
      font-weight: 700;
      cursor: pointer;
      backdrop-filter: blur(5px);
      -webkit-backdrop-filter: blur(5px);
      transition: all 0.3s ease;
      display: none;
    }

    #audio-btn:hover {
      background: rgba(0, 255, 0, 0.3);
      border-color: rgba(0, 255, 0, 0.8);
      transform: translateY(-2px);
    }

    #audio-btn.muted {
      background: rgba(255, 0, 0, 0.2);
      border-color: rgba(255, 0, 0, 0.5);
      color: #ff0000;
    }

    #audio-btn.muted:hover {
      background: rgba(255, 0, 0, 0.3);
      border-color: rgba(255, 0, 0, 0.8);
    }

    /* Pause Overlay */
    #pause-overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.9);
      display: none;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 50;
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
    }

    .pause-menu {
      background: rgba(0, 0, 0, 0.8);
      border: 2px solid rgba(0, 255, 255, 0.5);
      border-radius: 20px;
      padding: 40px;
      text-align: center;
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
    }

    .pause-title {
      color: #ffff00;
      font-family: 'Orbitron', sans-serif;
      font-size: 3em;
      font-weight: 900;
      text-shadow: 0 0 30px rgba(255, 255, 0, 1);
      margin-bottom: 30px;
    }

    .pause-buttons {
      display: flex;
      flex-direction: column;
      gap: 15px;
      min-width: 200px;
    }

    .pause-btn {
      padding: 15px 30px;
      font-size: 1.2em;
      font-family: 'Orbitron', sans-serif;
      font-weight: 700;
      border: none;
      border-radius: 10px;
      cursor: pointer;
      transition: all 0.3s ease;
      text-transform: uppercase;
      letter-spacing: 1px;
    }

    .pause-btn.resume {
      background: linear-gradient(45deg, #00ff88, #00cc66);
      color: black;
      box-shadow: 0 0 20px rgba(0, 255, 136, 0.5);
    }

    .pause-btn.resume:hover {
      background: linear-gradient(45deg, #00cc66, #00aa44);
      transform: translateY(-2px);
      box-shadow: 0 5px 25px rgba(0, 255, 136, 0.8);
    }

    .pause-btn.audio {
      background: linear-gradient(45deg, #ffaa00, #cc8800);
      color: white;
      box-shadow: 0 0 20px rgba(255, 170, 0, 0.5);
    }

    .pause-btn.audio:hover {
      background: linear-gradient(45deg, #cc8800, #aa6600);
      transform: translateY(-2px);
      box-shadow: 0 5px 25px rgba(255, 170, 0, 0.8);
    }

    .pause-btn.home {
      background: linear-gradient(45deg, #666, #444);
      color: white;
      box-shadow: 0 0 20px rgba(100, 100, 100, 0.5);
    }

    .pause-btn.home:hover {
      background: linear-gradient(45deg, #555, #333);
      transform: translateY(-2px);
      box-shadow: 0 5px 25px rgba(100, 100, 100, 0.8);
    }

    /* Enhanced Mobile Controls - iOS Optimized */
    #mobile-controls {
      position: fixed;
      bottom: 15px;
      left: 15px;
      right: 15px;
      display: flex;
      justify-content: space-between;
      align-items: flex-end;
      width: calc(100% - 30px);
      z-index: 20;
      pointer-events: none;
      /* iOS optimization */
      -webkit-transform: translateZ(0);
      transform: translateZ(0);
    }

    #joystick-container {
      position: relative;
      background: radial-gradient(circle, rgba(0, 255, 255, 0.15), rgba(0, 255, 255, 0.03));
      border-radius: 50%;
      border: 2px solid rgba(0, 255, 255, 0.3);
      display: flex;
      justify-content: center;
      align-items: center;
      flex-shrink: 0;
      box-shadow: 0 0 15px rgba(0, 255, 255, 0.2);
      pointer-events: auto;
      touch-action: none;
      /* iOS visibility fixes */
      -webkit-transform: translateZ(0);
      transform: translateZ(0);
      -webkit-backface-visibility: hidden;
      backface-visibility: hidden;
      /* Force rendering layer on iOS */
      will-change: transform;
      /* iOS touch optimization */
      -webkit-user-select: none;
      -webkit-touch-callout: none;
      -webkit-tap-highlight-color: transparent;
      /* Default size - can be customized */
      width: 120px;
      height: 120px;
      /* Custom positioning */
      left: 0;
      bottom: 0;
    }

    #joystick {
      background: radial-gradient(circle, rgba(255, 255, 255, 0.8), rgba(0, 255, 255, 0.5));
      border-radius: 50%;
      position: absolute;
      touch-action: none;
      border: 2px solid rgba(255, 255, 255, 0.7);
      box-shadow: 0 0 10px rgba(0, 255, 255, 0.4);
      transition: transform 0.1s ease;
      pointer-events: none;
      /* iOS visibility fixes */
      -webkit-transform: translateZ(0);
      transform: translateZ(0);
      -webkit-backface-visibility: hidden;
      backface-visibility: hidden;
      /* Force rendering layer on iOS */
      will-change: transform;
      /* Default size - can be customized */
      width: 60px;
      height: 60px;
      left: calc(50% - 30px);
      top: calc(50% - 30px);
    }

    #joystick.active {
      transform: scale(0.95) translateZ(0);
      -webkit-transform: scale(0.95) translateZ(0);
      box-shadow: 0 0 20px rgba(0, 255, 255, 0.7);
    }

    #shoot-button {
      background: radial-gradient(circle, rgba(255, 50, 50, 0.25), rgba(255, 0, 0, 0.08));
      border-radius: 50%;
      display: flex;
      justify-content: center;
      align-items: center;
      color: white;
      font-family: 'Orbitron', sans-serif;
      font-size: 20px;
      font-weight: 900;
      text-shadow: 0 0 8px rgba(255, 50, 50, 0.7);
      box-shadow: 0 0 15px rgba(255, 50, 50, 0.3);
      border: 2px solid rgba(255, 50, 50, 0.5);
      position: relative;
      overflow: hidden;
      transition: all 0.1s ease;
      cursor: pointer;
      pointer-events: auto;
      touch-action: manipulation;
      /* iOS visibility fixes */
      -webkit-transform: translateZ(0);
      transform: translateZ(0);
      -webkit-backface-visibility: hidden;
      backface-visibility: hidden;
      /* Force rendering layer on iOS */
      will-change: transform;
      /* iOS touch optimization */
      -webkit-user-select: none;
      -webkit-touch-callout: none;
      -webkit-tap-highlight-color: transparent;
      /* Default size - can be customized */
      width: 120px;
      height: 120px;
      /* Custom positioning */
      right: 0;
      bottom: 0;
    }

    #shoot-button::before {
      content: "";
      position: absolute;
      width: 100%;
      height: 100%;
      background: radial-gradient(circle, rgba(255, 100, 100, 0.3), transparent 70%);
      opacity: 0;
      transition: opacity 0.3s;
    }

    #shoot-button.active {
      transform: scale(0.95) translateZ(0);
      -webkit-transform: scale(0.95) translateZ(0);
      box-shadow: 0 0 25px rgba(255, 50, 50, 0.7);
    }

    #shoot-button.active::before {
      opacity: 1;
    }

    /* Mobile Control Customization Screen */
    #control-customization-screen {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: radial-gradient(circle, rgba(0, 0, 0, 0.95), rgba(0, 0, 0, 0.8));
      color: white;
      font-family: 'Orbitron', sans-serif;
      display: none;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 190;
      padding: 20px;
      box-sizing: border-box;
      text-align: center;
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
    }

    #control-customization-screen h1 {
      font-size: 4vw;
      margin-bottom: 30px;
      color: #00ffff;
      text-shadow: 0 0 30px rgba(0, 255, 255, 1);
      animation: title-glow 2s ease-in-out infinite alternate;
    }

    .control-options {
      display: flex;
      flex-direction: column;
      gap: 20px;
      max-width: 400px;
      width: 100%;
    }

    .control-option {
      background: rgba(0, 0, 0, 0.7);
      border: 2px solid rgba(0, 255, 255, 0.5);
      border-radius: 15px;
      padding: 20px;
    }

    .control-option h3 {
      color: #00ffff;
      margin-bottom: 15px;
      font-size: 1.2em;
    }

    .slider-container {
      display: flex;
      align-items: center;
      gap: 10px;
      margin: 10px 0;
    }

    .slider-label {
      color: #ffffff;
      font-size: 0.9em;
      min-width: 60px;
    }

    .control-slider {
      flex: 1;
      height: 8px;
      background: rgba(255, 255, 255, 0.2);
      border-radius: 4px;
      outline: none;
      -webkit-appearance: none;
    }

    .control-slider::-webkit-slider-thumb {
      appearance: none;
      width: 20px;
      height: 20px;
      background: #00ffff;
      border-radius: 50%;
      cursor: pointer;
      box-shadow: 0 0 10px rgba(0, 255, 255, 0.5);
    }

    .control-slider::-moz-range-thumb {
      width: 20px;
      height: 20px;
      background: #00ffff;
      border-radius: 50%;
      cursor: pointer;
      border: none;
      box-shadow: 0 0 10px rgba(0, 255, 255, 0.5);
    }

    .slider-value {
      color: #00ffff;
      font-weight: bold;
      min-width: 40px;
      text-align: right;
    }

    .control-customization-buttons {
      display: flex;
      gap: 20px;
      margin-top: 30px;
      flex-wrap: wrap;
      justify-content: center;
    }

    .control-customization-btn {
      padding: 15px 30px;
      font-size: 1.2em;
      font-family: 'Orbitron', sans-serif;
      font-weight: 700;
      border: none;
      border-radius: 10px;
      cursor: pointer;
      transition: all 0.3s ease;
      text-transform: uppercase;
      letter-spacing: 1px;
      min-width: 150px;
    }

    .control-customization-btn.save {
      background: linear-gradient(45deg, #00ff88, #00cc66);
      color: black;
      box-shadow: 0 0 20px rgba(0, 255, 136, 0.5);
    }

    .control-customization-btn.save:hover {
      background: linear-gradient(45deg, #00cc66, #00aa44);
      transform: translateY(-2px);
      box-shadow: 0 5px 25px rgba(0, 255, 136, 0.8);
    }

    .control-customization-btn.reset {
      background: linear-gradient(45deg, #ff8800, #cc6600);
      color: white;
      box-shadow: 0 0 20px rgba(255, 136, 0, 0.5);
    }

    .control-customization-btn.reset:hover {
      background: linear-gradient(45deg, #cc6600, #aa5500);
      transform: translateY(-2px);
      box-shadow: 0 5px 25px rgba(255, 136, 0, 0.8);
    }

    .control-customization-btn.back {
      background: linear-gradient(45deg, #666, #444);
      color: white;
      box-shadow: 0 0 20px rgba(100, 100, 100, 0.5);
    }

    .control-customization-btn.back:hover {
      background: linear-gradient(45deg, #555, #333);
      transform: translateY(-2px);
      box-shadow: 0 5px 25px rgba(100, 100, 100, 0.8);
    }

    /* Home Screen - Redesigned with Muted Colors */
    #home-screen {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: linear-gradient(135deg, #1a1a3a 0%, #242447 50%, #1a1a3a 100%);
      color: white;
      font-family: 'Orbitron', sans-serif;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 200;
      padding: 20px;
      box-sizing: border-box;
      text-align: center;
      overflow: hidden;
    }

    .home-background {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: 
        radial-gradient(circle at 20% 80%, rgba(70, 130, 180, 0.08) 0%, transparent 50%),
        radial-gradient(circle at 80% 20%, rgba(147, 112, 219, 0.08) 0%, transparent 50%),
        radial-gradient(circle at 40% 40%, rgba(255, 223, 0, 0.04) 0%, transparent 50%);
      animation: background-pulse 8s ease-in-out infinite alternate;
    }

    @keyframes background-pulse {
      0% { opacity: 0.6; }
      100% { opacity: 1; }
    }

    .home-content {
      position: relative;
      z-index: 1;
      max-width: 800px;
      width: 100%;
    }

    .game-title {
      font-size: clamp(3rem, 8vw, 6rem);
      font-weight: 900;
      margin-bottom: 20px;
      background: linear-gradient(45deg, #7B68EE, #9370DB, #8A2BE2, #7B68EE);
      background-size: 300% 300%;
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      animation: gradient-shift 4s ease-in-out infinite;
      text-shadow: 0 0 30px rgba(123, 104, 238, 0.3);
      line-height: 1.1;
    }

    @keyframes gradient-shift {
      0%, 100% { background-position: 0% 50%; }
      50% { background-position: 100% 50%; }
    }

    .game-subtitle {
      font-size: clamp(1rem, 3vw, 1.5rem);
      color: #87CEEB;
      margin-bottom: 40px;
      text-shadow: 0 0 15px rgba(135, 206, 235, 0.5);
      opacity: 0.9;
    }

    .home-stats {
      display: flex;
      justify-content: center;
      gap: 40px;
      margin-bottom: 50px;
      flex-wrap: wrap;
    }

    .stat-item {
      background: rgba(0, 0, 0, 0.3);
      border: 2px solid rgba(135, 206, 235, 0.4);
      border-radius: 15px;
      padding: 20px;
      min-width: 150px;
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      transition: all 0.3s ease;
    }

    .stat-item:hover {
      border-color: rgba(135, 206, 235, 0.7);
      transform: translateY(-5px);
      box-shadow: 0 10px 30px rgba(135, 206, 235, 0.2);
    }

    .stat-label {
      font-size: 0.9rem;
      color: #87CEEB;
      margin-bottom: 10px;
      text-transform: uppercase;
      letter-spacing: 1px;
    }

    .stat-value {
      font-size: 2rem;
      font-weight: 900;
      color: #ffffff;
      text-shadow: 0 0 10px rgba(255, 255, 255, 0.3);
    }

    .home-buttons {
      display: flex;
      flex-direction: column;
      gap: 20px;
      align-items: center;
    }

    .home-btn {
      padding: 20px 50px;
      font-size: 1.3rem;
      font-family: 'Orbitron', sans-serif;
      font-weight: 700;
      border: none;
      border-radius: 15px;
      cursor: pointer;
      transition: all 0.3s ease;
      text-transform: uppercase;
      letter-spacing: 2px;
      min-width: 250px;
      position: relative;
      overflow: hidden;
    }

    .home-btn::before {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.15), transparent);
      transition: left 0.5s;
    }

    .home-btn:hover::before {
      left: 100%;
    }

    .home-btn.start {
      background: linear-gradient(45deg, #5F9EA0, #4682B4);
      color: white;
      box-shadow: 0 0 20px rgba(95, 158, 160, 0.3);
    }

    .home-btn.start:hover {
      background: linear-gradient(45deg, #4682B4, #2F4F4F);
      transform: translateY(-3px);
      box-shadow: 0 8px 25px rgba(95, 158, 160, 0.5);
    }

    .home-btn.customize {
      background: linear-gradient(45deg, #CD853F, #A0522D);
      color: white;
      box-shadow: 0 0 20px rgba(205, 133, 63, 0.3);
    }

    .home-btn.customize:hover {
      background: linear-gradient(45deg, #A0522D, #8B4513);
      transform: translateY(-3px);
      box-shadow: 0 8px 25px rgba(205, 133, 63, 0.5);
    }

    .home-btn.trail {
      background: linear-gradient(45deg, #9370DB, #8A2BE2);
      color: white;
      box-shadow: 0 0 20px rgba(147, 112, 219, 0.3);
    }

    .home-btn.trail:hover {
      background: linear-gradient(45deg, #8A2BE2, #7B68EE);
      transform: translateY(-3px);
      box-shadow: 0 8px 25px rgba(147, 112, 219, 0.5);
    }

    .home-btn.difficulty {
      background: linear-gradient(45deg, #DAA520, #B8860B);
      color: white;
      box-shadow: 0 0 20px rgba(218, 165, 32, 0.3);
    }

    .home-btn.difficulty:hover {
      background: linear-gradient(45deg, #B8860B, #9ACD32);
      transform: translateY(-3px);
      box-shadow: 0 8px 25px rgba(218, 165, 32, 0.5);
    }

    /* Add new button for mobile control customization */
    .home-btn.controls {
      background: linear-gradient(45deg, #FF6347, #DC143C);
      color: white;
      box-shadow: 0 0 20px rgba(255, 99, 71, 0.3);
    }

    .home-btn.controls:hover {
      background: linear-gradient(45deg, #DC143C, #B22222);
      transform: translateY(-3px);
      box-shadow: 0 8px 25px rgba(255, 99, 71, 0.5);
    }

    /* Trail Customization Screen */
    #trail-screen {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: radial-gradient(circle, rgba(0, 0, 0, 0.95), rgba(0, 0, 0, 0.8));
      color: white;
      font-family: 'Orbitron', sans-serif;
      display: none;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 180;
      padding: 20px;
      box-sizing: border-box;
      text-align: center;
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
    }

    #trail-screen h1 {
      font-size: 4vw;
      margin-bottom: 30px;
      color: #aa44ff;
      text-shadow: 0 0 30px rgba(170, 68, 255, 1);
      animation: title-glow 2s ease-in-out infinite alternate;
    }

    .trail-preview {
      background: rgba(0, 0, 0, 0.7);
      border: 2px solid rgba(170, 68, 255, 0.5);
      border-radius: 15px;
      padding: 30px;
      margin-bottom: 30px;
      min-width: 300px;
    }

    .trail-preview h3 {
      color: #aa44ff;
      margin-bottom: 20px;
      font-size: 1.4em;
    }

    .trail-canvas {
      width: 250px;
      height: 150px;
      background: rgba(0, 20, 40, 0.8);
      border: 1px solid rgba(170, 68, 255, 0.3);
      border-radius: 10px;
      margin: 0 auto 20px;
      display: block;
    }

    .trail-type-selector {
      display: flex;
      gap: 10px;
      justify-content: center;
      margin-bottom: 20px;
    }

    .trail-type-btn {
      padding: 10px 20px;
      background: rgba(170, 68, 255, 0.2);
      border: 2px solid rgba(170, 68, 255, 0.5);
      color: #aa44ff;
      border-radius: 8px;
      cursor: pointer;
      transition: all 0.3s ease;
      font-family: 'Orbitron', sans-serif;
      font-size: 0.9em;
    }

    .trail-type-btn.active {
      background: rgba(170, 68, 255, 0.5);
      border-color: #aa44ff;
      color: white;
    }

    .trail-type-btn:hover {
      background: rgba(170, 68, 255, 0.3);
      transform: translateY(-2px);
    }

    .color-grid {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 15px;
      max-width: 400px;
      margin: 0 auto 30px;
    }

    .color-option {
      width: 80px;
      height: 80px;
      border-radius: 50%;
      cursor: pointer;
      border: 3px solid transparent;
      transition: all 0.3s ease;
      position: relative;
      overflow: hidden;
      /* iOS touch optimization */
      -webkit-user-select: none;
      -webkit-touch-callout: none;
      -webkit-tap-highlight-color: transparent;
    }

    .color-option::before {
      content: '';
      position: absolute;
      top: 50%;
      left: 50%;
      width: 0;
      height: 0;
      background: rgba(255, 255, 255, 0.3);
      border-radius: 50%;
      transform: translate(-50%, -50%);
      transition: all 0.3s ease;
    }

    .color-option:hover::before {
      width: 100%;
      height: 100%;
    }

    .color-option.selected {
      border-color: #ffffff;
      box-shadow: 0 0 20px rgba(255, 255, 255, 0.8);
      transform: scale(1.1);
    }

    .color-option.cyan { background: #00ffff; }
    .color-option.red { background: #ff4444; }
    .color-option.green { background: #00ff88; }
    .color-option.purple { background: #aa44ff; }
    .color-option.yellow { background: #ffdd00; }
    .color-option.orange { background: #ff6600; }
    .color-option.pink { background: #ff44aa; }
    .color-option.white { background: #ffffff; }

    .trail-buttons {
      display: flex;
      gap: 20px;
      flex-wrap: wrap;
      justify-content: center;
    }

    .trail-btn {
      padding: 15px 30px;
      font-size: 1.2em;
      font-family: 'Orbitron', sans-serif;
      font-weight: 700;
      border: none;
      border-radius: 10px;
      cursor: pointer;
      transition: all 0.3s ease;
      text-transform: uppercase;
      letter-spacing: 1px;
      min-width: 150px;
    }

    .trail-btn.save {
      background: linear-gradient(45deg, #00ff88, #00cc66);
      color: black;
      box-shadow: 0 0 20px rgba(0, 255, 136, 0.5);
    }

    .trail-btn.save:hover {
      background: linear-gradient(45deg, #00cc66, #00aa44);
      transform: translateY(-2px);
      box-shadow: 0 5px 25px rgba(0, 255, 136, 0.8);
    }

    .trail-btn.back {
      background: linear-gradient(45deg, #666, #444);
      color: white;
      box-shadow: 0 0 20px rgba(100, 100, 100, 0.5);
    }

    .trail-btn.back:hover {
      background: linear-gradient(45deg, #555, #333);
      transform: translateY(-2px);
      box-shadow: 0 5px 25px rgba(100, 100, 100, 0.8);
    }

    /* Ship Customization Screen */
    #customization-screen {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: radial-gradient(circle, rgba(0, 0, 0, 0.95), rgba(0, 0, 0, 0.8));
      color: white;
      font-family: 'Orbitron', sans-serif;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 160;
      padding: 20px;
      box-sizing: border-box;
      text-align: center;
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      display: none;
    }

    #customization-screen h1 {
      font-size: 5vw;
      margin-bottom: 30px;
      color: #00ffff;
      text-shadow: 0 0 30px rgba(0, 255, 255, 1);
      animation: title-glow 2s ease-in-out infinite alternate;
    }

    .customization-content {
      display: flex;
      flex-wrap: wrap;
      gap: 30px;
      justify-content: center;
      align-items: flex-start;
      max-width: 1200px;
      width: 100%;
    }

    .ship-preview {
      background: rgba(0, 0, 0, 0.7);
      border: 2px solid rgba(0, 255, 255, 0.5);
      border-radius: 15px;
      padding: 20px;
      min-width: 300px;
      flex: 1;
      max-width: 400px;
    }

    .ship-preview h3 {
      color: #00ffff;
      margin-bottom: 15px;
      font-size: 1.4em;
    }

    .ship-canvas {
      width: 200px;
      height: 150px;
      background: rgba(0, 20, 40, 0.8);
      border: 1px solid rgba(0, 255, 255, 0.3);
      border-radius: 10px;
      margin: 0 auto 15px;
      display: block;
    }

    .ship-stats {
      text-align: left;
      font-size: 0.9em;
    }

    .stat-bar {
      display: flex;
      align-items: center;
      margin: 8px 0;
      gap: 10px;
    }

    .stat-label {
      width: 80px;
      color: #00ffff;
    }

    .stat-value {
      flex: 1;
      height: 8px;
      background: rgba(255, 255, 255, 0.2);
      border-radius: 4px;
      overflow: hidden;
    }

    .stat-fill {
      height: 100%;
      border-radius: 4px;
      transition: width 0.3s ease;
    }

    .stat-fill.speed { background: linear-gradient(90deg, #00ff88, #00dd66); }
    .stat-fill.power { background: linear-gradient(90deg, #ff4444, #cc0000); }
    .stat-fill.defense { background: linear-gradient(90deg, #00aaff, #0088cc); }

    .ship-selection {
      flex: 2;
      min-width: 400px;
    }

    .ship-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
      gap: 15px;
      margin-bottom: 20px;
    }

    .ship-option {
      background: rgba(0, 0, 0, 0.6);
      border: 2px solid rgba(255, 255, 255, 0.3);
      border-radius: 10px;
      padding: 15px;
      cursor: pointer;
      transition: all 0.3s ease;
      text-align: center;
      /* iOS touch optimization */
      -webkit-user-select: none;
      -webkit-touch-callout: none;
      -webkit-tap-highlight-color: transparent;
    }

    .ship-option:hover {
      border-color: rgba(0, 255, 255, 0.8);
      transform: translateY(-2px);
      box-shadow: 0 5px 20px rgba(0, 255, 255, 0.3);
    }

    .ship-option.selected {
      border-color: #00ffff;
      background: rgba(0, 255, 255, 0.1);
      box-shadow: 0 0 20px rgba(0, 255, 255, 0.5);
    }

    .ship-option h4 {
      margin: 10px 0 5px;
      color: #ffffff;
      font-size: 1.1em;
    }

    .ship-option .ship-theme {
      font-size: 0.8em;
      opacity: 0.8;
      margin-bottom: 10px;
    }

    .mini-ship-canvas {
      width: 120px;
      height: 80px;
      background: rgba(0, 20, 40, 0.6);
      border: 1px solid rgba(0, 255, 255, 0.2);
      border-radius: 5px;
      margin: 0 auto 10px;
      display: block;
    }

    .customization-buttons {
      display: flex;
      gap: 20px;
      margin-top: 30px;
      flex-wrap: wrap;
      justify-content: center;
    }

    .customization-btn {
      padding: 15px 30px;
      font-size: 1.2em;
      font-family: 'Orbitron', sans-serif;
      font-weight: 700;
      border: none;
      border-radius: 10px;
      cursor: pointer;
      transition: all 0.3s ease;
      text-transform: uppercase;
      letter-spacing: 1px;
      min-width: 150px;
    }

    .customization-btn.start {
      background: linear-gradient(45deg, #00ff88, #00cc66);
      color: black;
      box-shadow: 0 0 20px rgba(0, 255, 136, 0.5);
    }

    .customization-btn.start:hover {
      background: linear-gradient(45deg, #00cc66, #00aa44);
      transform: translateY(-2px);
      box-shadow: 0 5px 25px rgba(0, 255, 136, 0.8);
    }

    .customization-btn.back {
      background: linear-gradient(45deg, #666, #444);
      color: white;
      box-shadow: 0 0 20px rgba(100, 100, 100, 0.5);
    }

    .customization-btn.back:hover {
      background: linear-gradient(45deg, #555, #333);
      transform: translateY(-2px);
      box-shadow: 0 5px 25px rgba(100, 100, 100, 0.8);
    }

    /* Difficulty Selection */
    #difficulty-screen {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: radial-gradient(circle, rgba(0, 0, 0, 0.9), rgba(0, 0, 0, 0.7));
      color: white;
      font-family: 'Orbitron', sans-serif;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 150;
      padding: 20px;
      box-sizing: border-box;
      text-align: center;
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      display: none;
    }

    #difficulty-screen h1 {
      font-size: 6vw;
      margin-bottom: 30px;
      color: #00ffff;
      text-shadow: 0 0 30px rgba(0, 255, 255, 1);
      animation: title-glow 2s ease-in-out infinite alternate;
    }

    @keyframes title-glow {
      0% { text-shadow: 0 0 30px rgba(0, 255, 255, 1); }
      100% { text-shadow: 0 0 50px rgba(0, 255, 255, 1), 0 0 80px rgba(0, 255, 255, 0.5); }
    }

    .difficulty-buttons {
      display: flex;
      flex-direction: column;
      gap: 20px;
      margin-top: 20px;
    }

    .difficulty-btn {
      padding: 20px 40px;
      font-size: 1.5em;
      font-family: 'Orbitron', sans-serif;
      font-weight: 700;
      border: none;
      border-radius: 15px;
      cursor: pointer;
      transition: all 0.3s ease;
      text-transform: uppercase;
      letter-spacing: 2px;
      min-width: 250px;
    }

    .difficulty-btn.easy {
      background: linear-gradient(45deg, #00ff88, #00cc66);
      color: black;
      box-shadow: 0 0 20px rgba(0, 255, 136, 0.5);
    }

    .difficulty-btn.easy:hover {
      background: linear-gradient(45deg, #00cc66, #00aa44);
      transform: translateY(-2px);
      box-shadow: 0 5px 25px rgba(0, 255, 136, 0.8);
    }

    .difficulty-btn.medium {
      background: linear-gradient(45deg, #ff8800, #cc6600);
      color: white;
      box-shadow: 0 0 20px rgba(255, 136, 0, 0.5);
    }

    .difficulty-btn.medium:hover {
      background: linear-gradient(45deg, #cc6600, #aa5500);
      transform: translateY(-2px);
      box-shadow: 0 5px 25px rgba(255, 136, 0, 0.8);
    }

    .difficulty-btn.hard {
      background: linear-gradient(45deg, #ff4444, #cc0000);
      color: white;
      box-shadow: 0 0 20px rgba(255, 68, 68, 0.5);
    }

    .difficulty-btn.hard:hover {
      background: linear-gradient(45deg, #cc0000, #aa0000);
      transform: translateY(-2px);
      box-shadow: 0 5px 25px rgba(255, 68, 68, 0.8);
    }

    .difficulty-description {
      font-size: 0.9em;
      margin-top: 10px;
      opacity: 0.8;
      line-height: 1.4;
    }

    .back-to-home {
      margin-top: 30px;
      padding: 15px 30px;
      font-size: 1.1em;
      font-family: 'Orbitron', sans-serif;
      font-weight: 700;
      background: linear-gradient(45deg, #666, #444);
      color: white;
      border: none;
      border-radius: 10px;
      cursor: pointer;
      transition: all 0.3s ease;
      text-transform: uppercase;
      letter-spacing: 1px;
    }

    .back-to-home:hover {
      background: linear-gradient(45deg, #555, #333);
      transform: translateY(-2px);
      box-shadow: 0 5px 25px rgba(100, 100, 100, 0.8);
    }

    /* Enhanced Game Over Screen with Standardized Buttons */
    #game-over-screen {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: radial-gradient(circle, rgba(0, 0, 0, 0.9), rgba(0, 0, 0, 0.7));
      color: white;
      font-family: 'Orbitron', sans-serif;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      text-shadow: 0 0 20px rgba(255, 50, 50, 0.8);
      z-index: 100;
      display: none;
      padding: 20px;
      box-sizing: border-box;
      text-align: center;
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
    }

    #game-over-screen h1 {
      font-size: 8vw;
      margin-bottom: 20px;
      line-height: 1;
      color: #ff3333;
      text-shadow: 0 0 30px rgba(255, 50, 50, 1);
      animation: game-over-glow 2s ease-in-out infinite alternate;
    }

    @keyframes game-over-glow {
      0% { text-shadow: 0 0 30px rgba(255, 50, 50, 1); }
      100% { text-shadow: 0 0 50px rgba(255, 50, 50, 1), 0 0 80px rgba(255, 50, 50, 0.5); }
    }

    #game-over-screen p {
      font-size: 4vw;
      margin: 10px 0;
      color: #00ffff;
      text-shadow: 0 0 15px rgba(0, 255, 255, 0.8);
    }

    /* Standardized Game Over Button Styles */
    .game-over-buttons {
      display: flex;
      flex-direction: column;
      gap: 15px;
      margin-top: 20px;
      align-items: center;
    }

    .game-over-btn {
      padding: 20px 40px;
      width: 280px;
      height: 70px;
      font-size: 1.3em;
      font-family: 'Orbitron', sans-serif;
      font-weight: 700;
      border: none;
      border-radius: 15px;
      cursor: pointer;
      transition: all 0.3s ease;
      text-transform: uppercase;
      letter-spacing: 2px;
      display: flex;
      align-items: center;
      justify-content: center;
      box-sizing: border-box;
    }

    .game-over-btn.restart {
      background: linear-gradient(45deg, #00ffff, #0080ff);
      color: black;
      box-shadow: 0 0 20px rgba(0, 255, 255, 0.5);
    }

    .game-over-btn.restart:hover {
      background: linear-gradient(45deg, #00cccc, #0066cc);
      transform: translateY(-2px);
      box-shadow: 0 5px 25px rgba(0, 255, 255, 0.8);
    }

    .game-over-btn.customize {
      background: linear-gradient(45deg, #CD853F, #A0522D);
      color: white;
      box-shadow: 0 0 20px rgba(205, 133, 63, 0.5);
    }

    .game-over-btn.customize:hover {
      background: linear-gradient(45deg, #A0522D, #8B4513);
      transform: translateY(-2px);
      box-shadow: 0 5px 25px rgba(205, 133, 63, 0.8);
    }

    .game-over-btn.difficulty {
      background: linear-gradient(45deg, #DAA520, #B8860B);
      color: white;
      box-shadow: 0 0 20px rgba(218, 165, 32, 0.5);
    }

    .game-over-btn.difficulty:hover {
      background: linear-gradient(45deg, #B8860B, #9ACD32);
      transform: translateY(-2px);
      box-shadow: 0 5px 25px rgba(218, 165, 32, 0.8);
    }

    .game-over-btn.home {
      background: linear-gradient(45deg, #666, #444);
      color: white;
      box-shadow: 0 0 20px rgba(100, 100, 100, 0.5);
    }

    .game-over-btn.home:hover {
      background: linear-gradient(45deg, #555, #333);
      transform: translateY(-2px);
      box-shadow: 0 5px 25px rgba(100, 100, 100, 0.8);
    }

    /* New High Score Animation */
    .new-high-score {
      animation: high-score-celebration 2s ease-in-out infinite alternate;
    }

    @keyframes high-score-celebration {
      0% { 
        color: #ffd700;
        text-shadow: 0 0 20px rgba(255, 215, 0, 1);
        transform: scale(1);
      }
      100% { 
        color: #ffff00;
        text-shadow: 0 0 30px rgba(255, 255, 0, 1), 0 0 50px rgba(255, 215, 0, 0.8);
        transform: scale(1.05);
      }
    }

    /* Enhanced Mobile Optimization with iOS Safe Areas */
    @media (max-width: 600px) {
      /* iOS safe area support */
      body {
        padding-top: env(safe-area-inset-top);
        padding-bottom: env(safe-area-inset-bottom);
        padding-left: env(safe-area-inset-left);
        padding-right: env(safe-area-inset-right);
      }

      #hud {
        font-size: 12px;
        padding: 8px;
        top: max(5px, env(safe-area-inset-top));
        left: max(5px, env(safe-area-inset-left));
        right: max(5px, env(safe-area-inset-right));
        width: auto;
        max-width: calc(100vw - 10px);
        box-sizing: border-box;
      }

      .hud-item {
        margin-bottom: 4px;
        gap: 6px;
      }

      .health-container {
        font-size: 14px;
        gap: 6px;
      }
      
      .hexagon-heart {
        width: 16px;
        height: 16px;
      }

      .hexagon-heart::before {
        width: 16px;
        height: 16px;
      }

      .hexagon-heart::after {
        width: 10px;
        height: 10px;
        top: 3px;
        left: 3px;
      }

      #boss-health-container {
        width: 90%;
        top: max(5px, env(safe-area-inset-top));
      }

      .boss-name {
        font-size: 12px;
      }

      #mobile-controls {
        bottom: max(10px, env(safe-area-inset-bottom));
        left: max(10px, env(safe-area-inset-left));
        right: max(10px, env(safe-area-inset-right));
        width: calc(100vw - max(20px, env(safe-area-inset-left) + env(safe-area-inset-right)));
      }

      #control-buttons {
        top: max(5px, env(safe-area-inset-top));
        right: max(5px, env(safe-area-inset-right));
      }

      #fullscreen-btn, #pause-btn, #audio-btn {
        padding: 8px 12px;
        font-size: 12px;
      }

      #game-over-screen h1 {
        font-size: 12vw;
      }

      #game-over-screen p {
        font-size: 6vw;
      }

      .game-over-btn {
        width: 250px;
        height: 60px;
        font-size: 1.1em;
        padding: 15px 30px;
      }

      #difficulty-screen h1 {
        font-size: 10vw;
      }

      #customization-screen h1 {
        font-size: 8vw;
        margin-bottom: 15px;
      }

      .customization-content {
        flex-direction: column;
        gap: 20px;
        max-height: 60vh;
        overflow-y: auto;
        padding: 10px;
      }

      .ship-preview {
        min-width: auto;
        max-width: none;
        padding: 15px;
        margin-bottom: 10px;
      }

      .ship-selection {
        min-width: auto;
        margin-bottom: 20px;
      }

      .ship-grid {
        grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
        gap: 10px;
      }

      .mini-ship-canvas {
        width: 80px;
        height: 50px;
      }

      .difficulty-btn {
        font-size: 1.0em;
        padding: 15px 25px;
        min-width: 180px;
      }

      .customization-buttons {
        flex-direction: column;
        align-items: center;
        position: fixed;
        bottom: max(20px, env(safe-area-inset-bottom));
        left: 50%;
        transform: translateX(-50%);
        background: rgba(0, 0, 0, 0.9);
        padding: 15px;
        border-radius: 15px;
        border: 1px solid rgba(0, 255, 255, 0.3);
        backdrop-filter: blur(10px);
        -webkit-backdrop-filter: blur(10px);
        z-index: 170;
        gap: 10px;
        width: calc(100% - 40px);
        max-width: 400px;
        box-sizing: border-box;
      }

      .customization-btn {
        width: 100%;
        padding: 12px 20px;
        font-size: 1.1em;
        margin: 0;
      }

      /* Ensure content doesn't overlap with fixed buttons */
      #customization-screen {
        padding-bottom: 120px;
      }

      .ship-stats {
        font-size: 0.8em;
      }

      .stat-bar {
        margin: 6px 0;
      }

      .stat-label {
        width: 60px;
        font-size: 0.9em;
      }

      .ship-option h4 {
        font-size: 1em;
        margin: 8px 0 4px;
      }

      .ship-option .ship-theme {
        font-size: 0.7em;
        margin-bottom: 8px;
      }

      .ship-option {
        padding: 10px;
      }

      .pause-title {
        font-size: 2em;
      }

      /* Better scrolling for mobile */
      .customization-content::-webkit-scrollbar {
        width: 4px;
      }

      .customization-content::-webkit-scrollbar-track {
        background: rgba(255, 255, 255, 0.1);
        border-radius: 2px;
      }

      .customization-content::-webkit-scrollbar-thumb {
        background: rgba(0, 255, 255, 0.5);
        border-radius: 2px;
      }

      .customization-content::-webkit-scrollbar-thumb:hover {
        background: rgba(0, 255, 255, 0.8);
      }

      /* Compact ship preview for mobile */
      .ship-canvas {
        width: 150px;
        height: 100px;
        margin-bottom: 10px;
      }

      .ship-preview h3 {
        font-size: 1.2em;
        margin-bottom: 10px;
      }

      .ship-selection h3 {
        font-size: 1.2em;
        margin-bottom: 15px;
      }

      /* Home screen mobile */
      .game-title {
        font-size: clamp(2rem, 10vw, 4rem);
      }

      .home-stats {
        gap: 20px;
      }

      .stat-item {
        min-width: 120px;
        padding: 15px;
      }

      .home-btn {
        min-width: 200px;
        padding: 15px 30px;
        font-size: 1.1em;
      }

      /* Trail screen mobile */
      #trail-screen h1 {
        font-size: 8vw;
      }

      .color-grid {
        grid-template-columns: repeat(4, 1fr);
        gap: 10px;
        max-width: 300px;
      }

      .color-option {
        width: 60px;
        height: 60px;
      }

      .trail-canvas {
        width: 200px;
        height: 120px;
      }

      .trail-type-selector {
        flex-direction: column;
        gap: 5px;
      }

      .trail-type-btn {
        padding: 8px 15px;
        font-size: 0.8em;
      }

      /* Control customization mobile */
      #control-customization-screen h1 {
        font-size: 8vw;
      }

      .control-options {
        max-width: 350px;
      }

      .control-option {
        padding: 15px;
      }

      .slider-container {
        flex-direction: column;
        gap: 5px;
        align-items: stretch;
      }

      .slider-label {
        min-width: auto;
        text-align: center;
      }

      .control-customization-btn {
        width: 100%;
        font-size: 1.0em;
        padding: 12px 20px;
      }

      .control-customization-buttons {
        flex-direction: column;
        width: 100%;
        max-width: 350px;
      }
    }

    /* Extra small screens with enhanced iOS support */
    @media (max-width: 400px) {
      #hud {
        font-size: 10px;
        padding: 6px;
      }

      .health-container {
        font-size: 12px;
      }

      .hexagon-heart {
        width: 14px;
        height: 14px;
      }

      #mobile-controls {
        bottom: max(8px, env(safe-area-inset-bottom));
        left: max(8px, env(safe-area-inset-left));
        right: max(8px, env(safe-area-inset-right));
      }
    }

    /* Loading Screen */
    #loading-screen {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: radial-gradient(circle, #0a0a2e, #000);
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 250;
      color: white;
      font-family: 'Orbitron', sans-serif;
    }

    .loading-text {
      font-size: 2em;
      margin-bottom: 30px;
      text-shadow: 0 0 20px rgba(0, 255, 255, 0.8);
      animation: loading-pulse 2s ease-in-out infinite;
    }

    @keyframes loading-pulse {
      0%, 100% { opacity: 0.5; }
      50% { opacity: 1; }
    }

    .loading-bar {
      width: 300px;
      height: 4px;
      background: rgba(255, 255, 255, 0.1);
      border-radius: 2px;
      overflow: hidden;
    }

    .loading-progress {
      height: 100%;
      background: linear-gradient(90deg, #00ffff, #0080ff);
      width: 0%;
      transition: width 0.3s ease;
      box-shadow: 0 0 10px rgba(0, 255, 255, 0.8);
    }

    /* Boss Warning */
    #boss-warning {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(255, 0, 0, 0.1);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 50;
      display: none;
      pointer-events: none;
    }

    .boss-warning-text {
      font-family: 'Orbitron', sans-serif;
      font-size: 6vw;
      font-weight: 900;
      color: #ff4444;
      text-shadow: 0 0 30px rgba(255, 68, 68, 1);
      animation: boss-warning-pulse 0.5s ease-in-out infinite alternate;
      text-align: center;
      line-height: 1.2;
    }

    @keyframes boss-warning-pulse {
      0% { 
        opacity: 0.8;
        transform: scale(1);
      }
      100% { 
        opacity: 1;
        transform: scale(1.05);
      }
    }

    /* iOS-specific fixes */
    @supports (-webkit-appearance: none) {
      #mobile-controls {
        /* Force hardware acceleration on iOS */
        -webkit-transform: translateZ(0);
        transform: translateZ(0);
        -webkit-backface-visibility: hidden;
        backface-visibility: hidden;
        /* Ensure visibility */
        opacity: 1 !important;
        visibility: visible !important;
      }

      #joystick-container,
      #shoot-button {
        /* Force rendering layer on iOS */
        -webkit-transform: translateZ(0);
        transform: translateZ(0);
        -webkit-backface-visibility: hidden;
        backface-visibility: hidden;
        /* Ensure visibility */
        opacity: 1 !important;
        visibility: visible !important;
        display: flex !important;
      }

      #joystick {
        /* Force rendering layer on iOS */
        -webkit-transform: translateZ(0);
        transform: translateZ(0);
        -webkit-backface-visibility: hidden;
        backface-visibility: hidden;
        /* Ensure visibility */
        opacity: 1 !important;
        visibility: visible !important;
      }
    }
  </style>
</head>
<body>
  <div id="loading-screen">
    <div class="loading-text">INITIALIZING SPACE SHOOTER</div>
    <div class="loading-bar">
      <div class="loading-progress" id="loading-progress"></div>
    </div>
  </div>

  <div id="home-screen">
    <div class="home-background"></div>
    <div class="home-content">
      <h1 class="game-title">SPACE SHOOTER</h1>
      <p class="game-subtitle">Enhanced Edition</p>
      
      <div class="home-stats">
        <div class="stat-item">
          <div class="stat-label">High Score</div>
          <div class="stat-value" id="home-high-score">0</div>
        </div>
        <div class="stat-item">
          <div class="stat-label">Games Played</div>
          <div class="stat-value" id="games-played">0</div>
        </div>
      </div>
      
      <div class="home-buttons">
        <button class="home-btn start" id="home-start-btn">Start Game</button>
        <button class="home-btn customize" id="home-customize-btn">Ship Customization</button>
        <button class="home-btn trail" id="home-trail-btn">Trail Effects</button>
        <button class="home-btn difficulty" id="home-difficulty-btn">Difficulty</button>
        <button class="home-btn controls" id="home-controls-btn" style="display: none;">Control Settings</button>
      </div>
    </div>
  </div>

  <div id="control-customization-screen">
    <h1>CONTROL CUSTOMIZATION</h1>
    
    <div class="control-options">
      <div class="control-option">
        <h3>Joystick Settings</h3>
        <div class="slider-container">
          <span class="slider-label">Size:</span>
          <input type="range" class="control-slider" id="joystick-size" min="80" max="160" value="120">
          <span class="slider-value" id="joystick-size-value">120px</span>
        </div>
        <div class="slider-container">
          <span class="slider-label">X Position:</span>
          <input type="range" class="control-slider" id="joystick-x" min="0" max="100" value="0">
          <span class="slider-value" id="joystick-x-value">0%</span>
        </div>
        <div class="slider-container">
          <span class="slider-label">Y Position:</span>
          <input type="range" class="control-slider" id="joystick-y" min="0" max="100" value="0">
          <span class="slider-value" id="joystick-y-value">0%</span>
        </div>
      </div>
      
      <div class="control-option">
        <h3>Shoot Button Settings</h3>
        <div class="slider-container">
          <span class="slider-label">Size:</span>
          <input type="range" class="control-slider" id="shoot-size" min="80" max="160" value="120">
          <span class="slider-value" id="shoot-size-value">120px</span>
        </div>
        <div class="slider-container">
          <span class="slider-label">X Position:</span>
          <input type="range" class="control-slider" id="shoot-x" min="0" max="100" value="100">
          <span class="slider-value" id="shoot-x-value">100%</span>
        </div>
        <div class="slider-container">
          <span class="slider-label">Y Position:</span>
          <input type="range" class="control-slider" id="shoot-y" min="0" max="100" value="0">
          <span class="slider-value" id="shoot-y-value">0%</span>
        </div>
      </div>
    </div>
    
    <div class="control-customization-buttons">
      <button class="control-customization-btn save" id="save-controls-btn">Save Settings</button>
      <button class="control-customization-btn reset" id="reset-controls-btn">Reset to Default</button>
      <button class="control-customization-btn back" id="back-to-home-controls-btn">Back to Home</button>
    </div>
  </div>

  <div id="trail-screen">
    <h1>TRAIL EFFECTS</h1>
    
    <div class="trail-preview">
      <h3>Trail Preview</h3>
      <div class="trail-type-selector">
        <button class="trail-type-btn active" data-type="particles">Particles</button>
        <button class="trail-type-btn" data-type="sparkles">Sparkles</button>
        <button class="trail-type-btn" data-type="smoke">Smoke</button>
        <button class="trail-type-btn" data-type="energy">Energy</button>
      </div>
      <canvas class="trail-canvas" id="trail-preview-canvas" width="250" height="150"></canvas>
    </div>
    
    <div class="color-grid">
      <div class="color-option cyan" data-color="#00ffff"></div>
      <div class="color-option red" data-color="#ff4444"></div>
      <div class="color-option green" data-color="#00ff88"></div>
      <div class="color-option purple" data-color="#aa44ff"></div>
      <div class="color-option yellow" data-color="#ffdd00"></div>
      <div class="color-option orange" data-color="#ff6600"></div>
      <div class="color-option pink" data-color="#ff44aa"></div>
      <div class="color-option white" data-color="#ffffff"></div>
    </div>
    
    <div class="trail-buttons">
      <button class="trail-btn save" id="save-trail-btn">Save & Apply</button>
      <button class="trail-btn back" id="back-to-home-trail-btn">Back to Home</button>
    </div>
  </div>

  <div id="difficulty-screen">
    <h1>SELECT DIFFICULTY</h1>
    <div class="difficulty-buttons">
      <button class="difficulty-btn easy" id="easy-btn">
        EASY MODE
        <div class="difficulty-description">Standard gameplay - enemies don't shoot back</div>
      </button>
      <button class="difficulty-btn medium" id="medium-btn">
        MEDIUM MODE
        <div class="difficulty-description">Balanced challenge - some enemies shoot back</div>
      </button>
      <button class="difficulty-btn hard" id="hard-btn">
        HARD MODE
        <div class="difficulty-description">Intense combat - all enemies shoot back at you!</div>
      </button>
    </div>
    <button class="back-to-home" id="back-to-home-difficulty-btn">Back to Home</button>
  </div>

  <div id="customization-screen">
    <h1>SHIP CUSTOMIZATION</h1>
    <div class="customization-content">
      <div class="ship-preview">
        <h3>Ship Preview</h3>
        <canvas class="ship-canvas" id="preview-canvas" width="200" height="150"></canvas>
        <div class="ship-stats">
          <div class="stat-bar">
            <span class="stat-label">Speed:</span>
            <div class="stat-value">
              <div class="stat-fill speed" id="speed-stat"></div>
            </div>
          </div>
          <div class="stat-bar">
            <span class="stat-label">Power:</span>
            <div class="stat-value">
              <div class="stat-fill power" id="power-stat"></div>
            </div>
          </div>
          <div class="stat-bar">
            <span class="stat-label">Defense:</span>
            <div class="stat-value">
              <div class="stat-fill defense" id="defense-stat"></div>
            </div>
          </div>
        </div>
      </div>
      
      <div class="ship-selection">
        <h3>Choose Your Ship</h3>
        <div class="ship-grid" id="ship-grid">
          <!-- Ship options will be populated by JavaScript -->
        </div>
      </div>
    </div>
    
    <div class="customization-buttons">
      <button class="customization-btn start" id="start-game-btn">Launch Mission</button>
      <button class="customization-btn back" id="back-to-home-customization-btn">Back to Home</button>
    </div>
  </div>

  <canvas id="game"></canvas>

  <!-- Control Buttons -->
  <div id="control-buttons">
    <button id="fullscreen-btn" style="display: none;">⛶ FULLSCREEN</button>
    <button id="pause-btn"><i class="fas fa-pause"></i> PAUSE</button>
    <button id="audio-btn"><i class="fas fa-volume-up"></i> AUDIO</button>
  </div>

  <!-- Pause Overlay -->
  <div id="pause-overlay">
    <div class="pause-menu">
      <div class="pause-title">PAUSED</div>
      <div class="pause-buttons">
        <button class="pause-btn resume" id="pause-resume-btn">Resume</button>
        <button class="pause-btn audio" id="pause-audio-btn">Toggle Audio</button>
        <button class="pause-btn home" id="pause-home-btn">Back to Home</button>
      </div>
    </div>
  </div>

  <div id="boss-warning">
    <div class="boss-warning-text">
      ⚠️ BOSS INCOMING ⚠️<br>
      PREPARE FOR BATTLE!
    </div>
  </div>

  <div id="boss-health-container">
    <div class="boss-name" id="boss-name">VOID DESTROYER</div>
    <div class="boss-health-bar">
      <div class="boss-health-fill" id="boss-health-fill"></div>
    </div>
  </div>

  <div id="hud">
    <div class="hud-item health-container">
      <span class="hud-label">HP:</span>
      <div class="hearts-container" id="hearts-container"></div>
    </div>
    <div class="hud-item">
      <span class="hud-label">SCORE:</span>
      <span class="hud-value" id="score">0</span>
    </div>
    <div class="hud-item">
      <span class="hud-label">HIGH:</span>
      <span class="hud-value high-score" id="high-score">0</span>
    </div>
    <div class="hud-item">
      <span class="hud-label">SHIELD:</span>
      <span class="hud-value" id="shield-time">0</span>
    </div>
    <div class="hud-item">
      <span class="hud-label">DIFFICULTY:</span>
      <span class="hud-value difficulty-indicator" id="difficulty-display">EASY</span>
    </div>
    <div class="hud-item">
      <span class="hud-label">SHIP:</span>
      <span class="hud-value" id="ship-name-display">CYBER STRIKER</span>
    </div>
  </div>

  <div id="mobile-controls">
    <div id="joystick-container">
      <div id="joystick"></div>
    </div>
    <div id="shoot-button">FIRE</div>
  </div>

  <div id="game-over-screen">
    <h1>GAME OVER</h1>
    <p>FINAL SCORE: <span id="final-score">0</span></p>
    <p id="high-score-message" style="display: none;">NEW HIGH SCORE!</p>
    <div class="game-over-buttons">
      <button class="game-over-btn restart" id="restart-button">RESTART MISSION</button>
      <button class="game-over-btn customize" id="customize-button">CUSTOMIZE SHIP</button>
      <button class="game-over-btn difficulty" id="difficulty-button">CHANGE DIFFICULTY</button>
      <button class="game-over-btn home" id="home-button">BACK TO HOME</button>
    </div>
  </div>

  <script>
    // Enhanced mobile device detection with iOS-specific handling
    const isMobile = /Mobi|Android|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
    const isIOS = /iPhone|iPad|iPod/i.test(navigator.userAgent);
    const isAndroid = /Android/i.test(navigator.userAgent);

    // Enhanced Audio Manager with iOS-specific fixes
    class AudioManager {
      constructor() {
        this.audioContext = null;
        this.currentTrack = null;
        this.musicGain = null;
        this.isMuted = this.loadMutedState();
        this.musicVolume = 0.05;
        this.isPlaying = false;
        this.fadeInDuration = 2000;
        this.fadeOutDuration = 1500;
        this.crossFadeDuration = 3000;
        this.trackEndedHandler = null;
        this.musicTracks = [
          'Background_Music.mp3',
          'Background_Music2.mp3', 
          'Background_Music3.mp3'
        ];
        this.loadedTracks = new Map();
        this.currentTrackIndex = -1;
        this.preloadingComplete = false;
        this.isUserInteracted = false;
        this.pendingPlay = false;
        this.initializeAudio();
      }

      async initializeAudio() {
        try {
          // Enhanced iOS-specific audio context creation
          const AudioContextClass = window.AudioContext || window.webkitAudioContext;
          if (!AudioContextClass) {
            console.warn('AudioContext not supported');
            this.createSynthesizedMusic();
            return;
          }

          this.audioContext = new AudioContextClass();
          this.musicGain = this.audioContext.createGain();
          this.musicGain.connect(this.audioContext.destination);
          this.musicGain.gain.value = this.isMuted ? 0 : this.musicVolume;

          // iOS requires user interaction before playing audio
          if (isIOS) {
            this.setupIOSAudioInteraction();
          } else {
            await this.preloadBackgroundMusic();
          }
        } catch (error) {
          console.warn('Audio initialization failed:', error);
          this.createSynthesizedMusic();
        }
      }

      setupIOSAudioInteraction() {
        const enableAudio = async () => {
          try {
            if (this.audioContext.state === 'suspended') {
              await this.audioContext.resume();
            }
            this.isUserInteracted = true;
            
            // Preload music after user interaction
            if (!this.preloadingComplete) {
              await this.preloadBackgroundMusic();
            }
            
            // Start pending playback
            if (this.pendingPlay) {
              this.pendingPlay = false;
              this.startBackgroundMusic();
            }
            
            // Remove listeners after first interaction
            document.removeEventListener('touchstart', enableAudio);
            document.removeEventListener('click', enableAudio);
          } catch (error) {
            console.warn('Failed to enable iOS audio:', error);
          }
        };

        document.addEventListener('touchstart', enableAudio, { once: true });
        document.addEventListener('click', enableAudio, { once: true });
      }

      async preloadBackgroundMusic() {
        console.log('Preloading background music tracks...');
        
        const loadPromises = this.musicTracks.map(async (trackName, index) => {
          try {
            const audio = new Audio();
            audio.preload = 'auto';
            audio.volume = this.isMuted ? 0 : this.musicVolume;
            
            // Enhanced iOS-specific settings
            if (isIOS) {
              audio.muted = this.isMuted; // iOS sometimes requires this
              audio.playsInline = true;
            }
            
            const loadPromise = new Promise((resolve, reject) => {
              const onLoadComplete = () => {
                console.log(`✓ Loaded: ${trackName}`);
                resolve(audio);
              };
              
              const onError = (error) => {
                console.warn(`✗ Failed to load: ${trackName}`, error);
                reject(error);
              };

              audio.addEventListener('canplaythrough', onLoadComplete, { once: true });
              audio.addEventListener('error', onError, { once: true });
              audio.addEventListener('abort', onError, { once: true });
              
              // iOS-specific timeout
              setTimeout(() => {
                if (!loadPromise.resolved) {
                  console.warn(`Timeout loading ${trackName}`);
                  reject(new Error('Load timeout'));
                }
              }, isIOS ? 10000 : 5000);
            });

            audio.src = trackName;
            audio.load();

            const loadedAudio = await loadPromise;
            this.loadedTracks.set(trackName, loadedAudio);
            
            return loadedAudio;
          } catch (error) {
            console.warn(`Failed to load ${trackName}:`, error);
            return null;
          }
        });

        try {
          const results = await Promise.allSettled(loadPromises);
          const successfulTracks = results
            .filter(result => result.status === 'fulfilled' && result.value !== null)
            .map(result => result.value);
          
          if (successfulTracks.length > 0) {
            console.log(`Successfully loaded ${successfulTracks.length} background tracks`);
            this.preloadingComplete = true;
          } else {
            console.log('No background music files found, creating synthesized music');
            this.createSynthesizedMusic();
          }
        } catch (error) {
          console.warn('Background music preloading failed:', error);
          this.createSynthesizedMusic();
        }
      }

      selectRandomTrack() {
        const availableTracks = Array.from(this.loadedTracks.values()).filter(track => track !== null);
        if (availableTracks.length === 0) return null;
        
        let newIndex;
        do {
          newIndex = Math.floor(Math.random() * availableTracks.length);
        } while (newIndex === this.currentTrackIndex && availableTracks.length > 1);
        
        this.currentTrackIndex = newIndex;
        return availableTracks[newIndex];
      }

      async startBackgroundMusic() {
        if (this.isPlaying) return;

        // iOS requires user interaction first
        if (isIOS && !this.isUserInteracted) {
          this.pendingPlay = true;
          return;
        }

        try {
          if (this.audioContext && this.audioContext.state === 'suspended') {
            await this.audioContext.resume();
          }

          if (!this.preloadingComplete || this.loadedTracks.size === 0) {
            console.log('No tracks available, starting synthesized music');
            this.startSynthesizedMusic();
            return;
          }

          const selectedTrack = this.selectRandomTrack();
          if (!selectedTrack) {
            console.log('No valid track selected, starting synthesized music');
            this.startSynthesizedMusic();
            return;
          }

          // Stop any currently playing track
          await this.stopCurrentTrack();

          this.currentTrack = selectedTrack;
          
          this.trackEndedHandler = () => {
            if (this.isPlaying) {
              console.log('Track ended, selecting new random track...');
              this.switchToRandomTrack();
            }
          };
          
          this.currentTrack.addEventListener('ended', this.trackEndedHandler);
          
          if (!this.isMuted) {
            this.currentTrack.volume = 0;
            this.currentTrack.currentTime = 0;
            
            // Enhanced iOS play handling
            try {
              await this.currentTrack.play();
              this.fadeInTrack(this.currentTrack);
            } catch (playError) {
              console.warn('Failed to play track:', playError);
              if (isIOS) {
                // iOS may require muted start
                this.currentTrack.muted = true;
                await this.currentTrack.play();
                this.currentTrack.muted = this.isMuted;
                this.fadeInTrack(this.currentTrack);
              }
            }
          }
          
          this.isPlaying = true;
          console.log('Background music started with random track');
        } catch (error) {
          console.warn('Failed to start background music:', error);
          this.startSynthesizedMusic();
        }
      }

      async stopCurrentTrack() {
        if (this.currentTrack) {
          try {
            if (this.trackEndedHandler) {
              this.currentTrack.removeEventListener('ended', this.trackEndedHandler);
            }
            
            if (!this.currentTrack.paused) {
              await this.fadeOutTrack(this.currentTrack);
            } else {
              this.currentTrack.pause();
            }
          } catch (error) {
            console.warn('Error stopping current track:', error);
          }
          this.currentTrack = null;
        }
      }

      async switchToRandomTrack() {
        if (!this.isPlaying || this.loadedTracks.size === 0) return;

        const newTrack = this.selectRandomTrack();
        if (!newTrack || newTrack === this.currentTrack) return;

        try {
          const oldTrack = this.currentTrack;
          
          if (oldTrack && this.trackEndedHandler) {
            oldTrack.removeEventListener('ended', this.trackEndedHandler);
          }
          
          newTrack.volume = 0;
          newTrack.currentTime = 0;
          this.currentTrack = newTrack;
          
          this.currentTrack.addEventListener('ended', this.trackEndedHandler);
          
          if (!this.isMuted) {
            await newTrack.play();
            this.crossFadeTracks(oldTrack, newTrack);
          }
          
          console.log('Switched to new random track');
        } catch (error) {
          console.warn('Failed to switch tracks:', error);
        }
      }

      fadeInTrack(track) {
        if (!track || this.isMuted) return;
        
        const fadeSteps = 50;
        const stepDuration = this.fadeInDuration / fadeSteps;
        const volumeStep = this.musicVolume / fadeSteps;
        let currentStep = 0;
        
        const fadeInterval = setInterval(() => {
          if (currentStep >= fadeSteps || !this.isPlaying) {
            clearInterval(fadeInterval);
            if (this.isPlaying && !this.isMuted) {
              track.volume = this.musicVolume;
            }
            return;
          }
          
          track.volume = Math.min(volumeStep * currentStep, this.musicVolume);
          currentStep++;
        }, stepDuration);
      }

      fadeOutTrack(track) {
        if (!track) return Promise.resolve();
        
        return new Promise((resolve) => {
          const fadeSteps = 30;
          const stepDuration = this.fadeOutDuration / fadeSteps;
          const initialVolume = track.volume;
          const volumeStep = initialVolume / fadeSteps;
          let currentStep = 0;
          
          const fadeInterval = setInterval(() => {
            if (currentStep >= fadeSteps) {
              clearInterval(fadeInterval);
              track.volume = 0;
              track.pause();
              resolve();
              return;
            }
            
            track.volume = Math.max(initialVolume - (volumeStep * currentStep), 0);
            currentStep++;
          }, stepDuration);
        });
      }

      crossFadeTracks(oldTrack, newTrack) {
        if (!oldTrack || !newTrack || this.isMuted) return;
        
        const fadeSteps = 60;
        const stepDuration = this.crossFadeDuration / fadeSteps;
        const volumeStep = this.musicVolume / fadeSteps;
        let currentStep = 0;
        
        const crossFadeInterval = setInterval(() => {
          if (currentStep >= fadeSteps || !this.isPlaying) {
            clearInterval(crossFadeInterval);
            if (this.isPlaying && !this.isMuted) {
              newTrack.volume = this.musicVolume;
            }
            oldTrack.volume = 0;
            oldTrack.pause();
            return;
          }
          
          oldTrack.volume = Math.max(this.musicVolume - (volumeStep * currentStep), 0);
          newTrack.volume = Math.min(volumeStep * currentStep, this.musicVolume);
          
          currentStep++;
        }, stepDuration);
      }

      async stopBackgroundMusic() {
        if (!this.isPlaying) return;

        try {
          await this.stopCurrentTrack();
          this.isPlaying = false;
          this.pendingPlay = false;
          console.log('Background music stopped');
        } catch (error) {
          console.warn('Failed to stop background music:', error);
        }
      }

      createSynthesizedMusic() {
        if (!this.audioContext) return;

        try {
          const oscillator = this.audioContext.createOscillator();
          const gainNode = this.audioContext.createGain();
          
          oscillator.type = 'sine';
          oscillator.frequency.setValueAtTime(220, this.audioContext.currentTime);
          
          gainNode.gain.setValueAtTime(0, this.audioContext.currentTime);
          gainNode.gain.linearRampToValueAtTime(this.musicVolume * 0.3, this.audioContext.currentTime + 2);
          
          oscillator.connect(gainNode);
          gainNode.connect(this.musicGain);
          
          let time = this.audioContext.currentTime;
          const notes = [220, 246.94, 261.63, 293.66, 329.63, 293.66, 261.63, 246.94];
          
          notes.forEach((freq, index) => {
            oscillator.frequency.setValueAtTime(freq, time + index * 2);
          });
          
          oscillator.start();
          
          this.preloadingComplete = true;
        } catch (error) {
          console.warn('Synthesized music creation failed:', error);
        }
      }

      startSynthesizedMusic() {
        if (!this.audioContext || this.isPlaying) return;
        
        try {
          const oscillator = this.audioContext.createOscillator();
          const gainNode = this.audioContext.createGain();
          
          oscillator.type = 'sine';
          oscillator.frequency.setValueAtTime(220, this.audioContext.currentTime);
          
          gainNode.gain.setValueAtTime(this.isMuted ? 0 : this.musicVolume * 0.3, this.audioContext.currentTime);
          
          oscillator.connect(gainNode);
          gainNode.connect(this.musicGain);
          
          oscillator.start();
          this.isPlaying = true;
          
          this.createSynthesizedLoop();
        } catch (error) {
          console.warn('Failed to start synthesized music:', error);
        }
      }

      createSynthesizedLoop() {
        if (!this.isPlaying || !this.audioContext) return;
        
        setInterval(() => {
          if (this.isPlaying && !this.isMuted && this.audioContext) {
            try {
              const oscillator = this.audioContext.createOscillator();
              const gainNode = this.audioContext.createGain();
              
              oscillator.type = 'sine';
              gainNode.gain.setValueAtTime(this.musicVolume * 0.3, this.audioContext.currentTime);
              
              oscillator.connect(gainNode);
              gainNode.connect(this.musicGain);
              
              const notes = [220, 246.94, 261.63, 293.66, 329.63, 293.66, 261.63, 246.94];
              let currentTime = this.audioContext.currentTime;
              
              notes.forEach((freq, index) => {
                oscillator.frequency.setValueAtTime(freq, currentTime + index * 2);
              });
              
              oscillator.start();
              oscillator.stop(currentTime + 16);
            } catch (error) {
              console.warn('Synthesized music loop error:', error);
            }
          }
        }, 16000);
      }

      toggleMute() {
        this.isMuted = !this.isMuted;
        this.saveMutedState();
        
        try {
          if (this.currentTrack) {
            this.currentTrack.volume = this.isMuted ? 0 : this.musicVolume;
            this.currentTrack.muted = this.isMuted; // iOS compatibility
          }
          
          if (this.musicGain) {
            this.musicGain.gain.setValueAtTime(
              this.isMuted ? 0 : this.musicVolume,
              this.audioContext.currentTime
            );
          }
        } catch (error) {
          console.warn('Failed to toggle mute:', error);
        }
        
        console.log(`Audio ${this.isMuted ? 'muted' : 'unmuted'}`);
        return this.isMuted;
      }

      loadMutedState() {
        try {
          return localStorage.getItem('spaceShooterMuted') === 'true';
        } catch (error) {
          return false;
        }
      }

      saveMutedState() {
        try {
          localStorage.setItem('spaceShooterMuted', this.isMuted.toString());
        } catch (error) {
          console.warn('Could not save muted state:', error);
        }
      }

      getMutedState() {
        return this.isMuted;
      }

      async restartBackgroundMusic() {
        console.log('Restarting background music with new random track...');
        await this.stopBackgroundMusic();
        
        setTimeout(() => {
          this.startBackgroundMusic();
        }, 500);
      }
    }

    // Initialize audio manager
    const audioManager = new AudioManager();

    // High Score Management System with proper display updates
    class HighScoreManager {
      constructor() {
        this.storageKey = 'spaceShooterHighScore';
        this.gamesPlayedKey = 'spaceShooterGamesPlayed';
        this.highScore = this.loadHighScore();
        this.gamesPlayed = this.loadGamesPlayed();
      }

      loadHighScore() {
        try {
          const saved = localStorage.getItem(this.storageKey);
          return saved ? parseInt(saved, 10) : 0;
        } catch (error) {
          console.warn('Could not load high score:', error);
          return 0;
        }
      }

      loadGamesPlayed() {
        try {
          const saved = localStorage.getItem(this.gamesPlayedKey);
          return saved ? parseInt(saved, 10) : 0;
        } catch (error) {
          console.warn('Could not load games played:', error);
          return 0;
        }
      }

      saveHighScore(score) {
        try {
          localStorage.setItem(this.storageKey, score.toString());
          this.highScore = score;
          this.updateAllHighScoreDisplays();
          return true;
        } catch (error) {
          console.warn('Could not save high score:', error);
          return false;
        }
      }

      incrementGamesPlayed() {
        try {
          this.gamesPlayed++;
          localStorage.setItem(this.gamesPlayedKey, this.gamesPlayed.toString());
          this.updateAllGamesPlayedDisplays();
        } catch (error) {
          console.warn('Could not save games played:', error);
        }
      }

      updateAllHighScoreDisplays() {
        const formattedScore = this.formatScore(this.highScore);
        const homeHighScore = document.getElementById('home-high-score');
        const hudHighScore = document.getElementById('high-score');
        
        if (homeHighScore) homeHighScore.textContent = formattedScore;
        if (hudHighScore) hudHighScore.textContent = formattedScore;
      }

      updateAllGamesPlayedDisplays() {
        const gamesPlayedElement = document.getElementById('games-played');
        if (gamesPlayedElement) {
          gamesPlayedElement.textContent = this.gamesPlayed;
        }
      }

      checkAndUpdateHighScore(currentScore) {
        if (currentScore > this.highScore) {
          this.saveHighScore(currentScore);
          return true;
        }
        return false;
      }

      getHighScore() {
        return this.highScore;
      }

      getGamesPlayed() {
        return this.gamesPlayed;
      }

      formatScore(score) {
        return score.toLocaleString();
      }

      initializeDisplays() {
        this.updateAllHighScoreDisplays();
        this.updateAllGamesPlayedDisplays();
      }
    }

    // Initialize high score manager
    const highScoreManager = new HighScoreManager();

    // Enhanced Trail Color and Type Manager
    class TrailEffectManager {
      constructor() {
        this.storageKey = 'spaceShooterTrailSettings';
        this.settings = this.loadTrailSettings();
        this.colors = {
          '#00ffff': 'Cyan',
          '#ff4444': 'Red',
          '#00ff88': 'Green',
          '#aa44ff': 'Purple',
          '#ffdd00': 'Yellow',
          '#ff6600': 'Orange',
          '#ff44aa': 'Pink',
          '#ffffff': 'White'
        };
        this.types = {
          'particles': 'Particles',
          'sparkles': 'Sparkles',
          'smoke': 'Smoke',
          'energy': 'Energy'
        };
      }

      loadTrailSettings() {
        try {
          const saved = localStorage.getItem(this.storageKey);
          return saved ? JSON.parse(saved) : { color: '#00ffff', type: 'particles' };
        } catch (error) {
          console.warn('Could not load trail settings:', error);
          return { color: '#00ffff', type: 'particles' };
        }
      }

      saveTrailSettings() {
        try {
          localStorage.setItem(this.storageKey, JSON.stringify(this.settings));
          return true;
        } catch (error) {
          console.warn('Could not save trail settings:', error);
          return false;
        }
      }

      getCurrentColor() {
        return this.settings.color;
      }

      getCurrentType() {
        return this.settings.type;
      }

      getColorName(color) {
        return this.colors[color] || 'Unknown';
      }

      getTypeName(type) {
        return this.types[type] || 'Unknown';
      }

      setColor(color) {
        if (this.colors[color]) {
          this.settings.color = color;
          this.saveTrailSettings();
          return true;
        }
        return false;
      }

      setType(type) {
        if (this.types[type]) {
          this.settings.type = type;
          this.saveTrailSettings();
          return true;
        }
        return false;
      }

      createTrailParticle(x, y, angle, speed, size = null) {
        const color = this.getCurrentColor();
        const type = this.getCurrentType();
        
        switch (type) {
          case 'sparkles':
            return new SparkleParticle(x, y, angle, speed, color, size);
          case 'smoke':
            return new SmokeParticle(x, y, angle, speed, color, size);
          case 'energy':
            return new EnergyParticle(x, y, angle, speed, color, size);
          default:
            return new Particle(x, y, angle, speed, color, size, 'thruster');
        }
      }
    }

    // Initialize trail effect manager
    const trailEffectManager = new TrailEffectManager();

    // Mobile Control Customization Manager
    class MobileControlManager {
      constructor() {
        this.storageKey = 'spaceShooterMobileControls';
        this.settings = this.loadControlSettings();
        this.isCustomizing = false;
      }

      loadControlSettings() {
        try {
          const saved = localStorage.getItem(this.storageKey);
          return saved ? JSON.parse(saved) : {
            joystick: { size: 120, x: 0, y: 0 },
            shoot: { size: 120, x: 100, y: 0 }
          };
        } catch (error) {
          console.warn('Could not load control settings:', error);
          return {
            joystick: { size: 120, x: 0, y: 0 },
            shoot: { size: 120, x: 100, y: 0 }
          };
        }
      }

      saveControlSettings() {
        try {
          localStorage.setItem(this.storageKey, JSON.stringify(this.settings));
          return true;
        } catch (error) {
          console.warn('Could not save control settings:', error);
          return false;
        }
      }

      applySettings() {
        if (!isMobile) return;

        const joystickContainer = document.getElementById('joystick-container');
        const joystick = document.getElementById('joystick');
        const shootButton = document.getElementById('shoot-button');

        if (joystickContainer && joystick && shootButton) {
          // Apply joystick settings
          const js = this.settings.joystick;
          joystickContainer.style.width = js.size + 'px';
          joystickContainer.style.height = js.size + 'px';
          joystickContainer.style.left = js.x + '%';
          joystickContainer.style.bottom = js.y + '%';
          
          joystick.style.width = (js.size / 2) + 'px';
          joystick.style.height = (js.size / 2) + 'px';
          joystick.style.left = 'calc(50% - ' + (js.size / 4) + 'px)';
          joystick.style.top = 'calc(50% - ' + (js.size / 4) + 'px)';

          // Apply shoot button settings
          const sb = this.settings.shoot;
          shootButton.style.width = sb.size + 'px';
          shootButton.style.height = sb.size + 'px';
          
          // Handle positioning - 100% means right side
          if (sb.x >= 50) {
            shootButton.style.right = (100 - sb.x) + '%';
            shootButton.style.left = 'auto';
          } else {
            shootButton.style.left = sb.x + '%';
            shootButton.style.right = 'auto';
          }
          shootButton.style.bottom = sb.y + '%';

          // Update font size based on button size
          shootButton.style.fontSize = Math.min(sb.size / 6, 20) + 'px';
        }
      }

      resetToDefaults() {
        this.settings = {
          joystick: { size: 120, x: 0, y: 0 },
          shoot: { size: 120, x: 100, y: 0 }
        };
        this.saveControlSettings();
        this.applySettings();
      }

      updateSetting(control, property, value) {
        if (this.settings[control]) {
          this.settings[control][property] = value;
          this.applySettings();
        }
      }
    }

    // Initialize mobile control manager
    const mobileControlManager = new MobileControlManager();

    // Difficulty Configuration System
    class DifficultyManager {
      constructor() {
        this.difficulties = {
          easy: {
            name: 'EASY',
            className: 'difficulty-indicator',
            enemySpeed: 1.5,
            enemyShootChance: 0,
            enemySpawnRate: 180,
            enemyDamage: 1,
            bossHealth: 150,
            bossSpeed: 1,
            bossShootCooldown: 1500,
            description: 'Standard gameplay - enemies don\'t shoot back'
          },
          medium: {
            name: 'MEDIUM',
            className: 'difficulty-indicator difficulty-medium',
            enemySpeed: 1.8,
            enemyShootChance: 0.3,
            enemySpawnRate: 150,
            enemyDamage: 1,
            bossHealth: 200,
            bossSpeed: 1.2,
            bossShootCooldown: 1200,
            description: 'Balanced challenge - some enemies shoot back'
          },
          hard: {
            name: 'HARD',
            className: 'difficulty-indicator difficulty-hard',
            enemySpeed: 2.2,
            enemyShootChance: 1,
            enemySpawnRate: 120,
            enemyDamage: 1,
            bossHealth: 250,
            bossSpeed: 1.5,
            bossShootCooldown: 1000,
            description: 'Intense combat - all enemies shoot back at you!'
          }
        };
        this.currentDifficulty = 'easy';
      }

      setDifficulty(difficulty) {
        if (this.difficulties[difficulty]) {
          this.currentDifficulty = difficulty;
          return true;
        }
        return false;
      }

      getCurrentConfig() {
        return this.difficulties[this.currentDifficulty];
      }

      getDifficultyName() {
        return this.difficulties[this.currentDifficulty].name;
      }

      getDifficultyClass() {
        return this.difficulties[this.currentDifficulty].className;
      }
    }

    // Initialize difficulty manager
    const difficultyManager = new DifficultyManager();

    // Enhanced Fullscreen API implementation with improved mobile support and FIXED method name
    class FullscreenManager {
      constructor() {
        this.isFullscreen = false;
        this.fullscreenBtn = document.getElementById('fullscreen-btn');
        this.bindEvents();
        this.mobileFullscreenSupported = this.checkMobileFullscreenSupport(); // FIXED: Renamed method to match the call
      }

      checkMobileFullscreenSupport() { // FIXED: Renamed from checkMobileFullscreenSupported to checkMobileFullscreenSupport
        const userAgent = navigator.userAgent.toLowerCase();
        const isIOS = /iphone|ipad|ipod/.test(userAgent);
        const isAndroid = /android/.test(userAgent);
        
        if (isIOS) {
          return false;
        }
        
        if (isAndroid) {
          return !!(
            document.documentElement.requestFullscreen ||
            document.documentElement.webkitRequestFullscreen ||
            document.documentElement.mozRequestFullScreen
          );
        }
        
        return this.isFullscreenSupported();
      }

      bindEvents() {
        this.fullscreenBtn.addEventListener('click', () => this.toggleFullscreen());
        
        document.addEventListener('fullscreenchange', () => this.handleFullscreenChange());
        document.addEventListener('webkitfullscreenchange', () => this.handleFullscreenChange());
        document.addEventListener('mozfullscreenchange', () => this.handleFullscreenChange());
        document.addEventListener('MSFullscreenChange', () => this.handleFullscreenChange());
      }

      async enterFullscreen() {
        try {
          const element = document.documentElement;
          
          if (element.requestFullscreen) {
            await element.requestFullscreen({ navigationUI: "hide" });
          } else if (element.webkitRequestFullscreen) {
            await element.webkitRequestFullscreen(Element.ALLOW_KEYBOARD_INPUT);
          } else if (element.mozRequestFullScreen) {
            await element.mozRequestFullScreen();
          } else if (element.msRequestFullscreen) {
            await element.msRequestFullscreen();
          } else {
            this.simulateFullscreen();
            return true;
          }
          
          return true;
        } catch (error) {
          console.warn('Fullscreen request failed:', error);
          this.simulateFullscreen();
          return false;
        }
      }

      simulateFullscreen() {
        if (window.screen && window.screen.orientation) {
          try {
            window.screen.orientation.lock('landscape-primary').catch(() => {});
          } catch (e) {}
        }
        
        setTimeout(() => {
          window.scrollTo(0, 1);
        }, 100);
        
        this.isFullscreen = true;
        this.updateButtonText();
      }

      async exitFullscreen() {
        try {
          if (document.exitFullscreen) {
            await document.exitFullscreen();
          } else if (document.webkitExitFullscreen) {
            await document.webkitExitFullscreen();
          } else if (document.mozCancelFullScreen) {
            await document.mozCancelFullScreen();
          } else if (document.msExitFullscreen) {
            await document.msExitFullscreen();
          }
          
          return true;
        } catch (error) {
          console.warn('Exit fullscreen failed:', error);
          return false;
        }
      }

      async toggleFullscreen() {
        if (this.mobileFullscreenSupported || !this.isMobile()) {
          if (this.isFullscreen) {
            await this.exitFullscreen();
          } else {
            await this.enterFullscreen();
          }
        } else {
          this.simulateFullscreen();
        }
      }

      isMobile() {
        return /Mobi|Android|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
      }

      isFullscreenSupported() {
        return !!(
          document.fullscreenEnabled ||
          document.webkitFullscreenEnabled ||
          document.mozFullScreenEnabled ||
          document.msFullscreenEnabled
        );
      }

      handleFullscreenChange() {
        this.isFullscreen = !!(
          document.fullscreenElement ||
          document.webkitFullscreenElement ||
          document.mozFullScreenElement ||
          document.msFullscreenElement
        );

        this.updateButtonText();
        
        setTimeout(() => {
          resizeCanvas();
        }, 100);
      }

      updateButtonText() {
        this.fullscreenBtn.textContent = this.isFullscreen ? '⛶ EXIT FULLSCREEN' : '⛶ FULLSCREEN';
      }

      async autoEnterFullscreen() {
        if ((this.mobileFullscreenSupported || !this.isMobile()) && !this.isFullscreen) {
          await this.enterFullscreen();
        }
      }

      show() {
        this.fullscreenBtn.style.display = 'block';
      }

      hide() {
        this.fullscreenBtn.style.display = 'none';
      }
    }

    // Initialize fullscreen manager
    const fullscreenManager = new FullscreenManager();

    // Pause functionality
    class PauseManager {
      constructor() {
        this.isPaused = false;
        this.pauseBtn = document.getElementById('pause-btn');
        this.pauseOverlay = document.getElementById('pause-overlay');
        this.resumeBtn = document.getElementById('pause-resume-btn');
        this.audioBtn = document.getElementById('pause-audio-btn');
        this.homeBtn = document.getElementById('pause-home-btn');
        this.bindEvents();
      }

      bindEvents() {
        this.pauseBtn.addEventListener('click', () => this.togglePause());
        this.resumeBtn.addEventListener('click', () => this.resume());
        this.audioBtn.addEventListener('click', () => this.toggleAudio());
        this.homeBtn.addEventListener('click', () => this.goHome());
        
        document.addEventListener('keydown', (e) => {
          if (e.key === 'p' || e.key === 'P' || e.key === 'Escape') {
            if (gameRunning) {
              this.togglePause();
            }
          }
        });
      }

      pause() {
        if (!gameRunning || this.isPaused) return;
        
        this.isPaused = true;
        this.pauseBtn.innerHTML = '<i class="fa-solid fa-play"></i> RESUME';
        this.pauseBtn.classList.add('paused');
        this.pauseOverlay.style.display = 'flex';
        
        if (animationFrameId) {
          cancelAnimationFrame(animationFrameId);
        }
      }

      resume() {
        if (!this.isPaused) return;
        
        this.isPaused = false;
        this.pauseBtn.innerHTML = '<i class="fas fa-pause"></i> PAUSE';
        this.pauseBtn.classList.remove('paused');
        this.pauseOverlay.style.display = 'none';
        
        if (gameRunning) {
          animationFrameId = requestAnimationFrame(gameLoop);
        }
      }

      togglePause() {
        if (this.isPaused) {
          this.resume();
        } else {
          this.pause();
        }
      }

      toggleAudio() {
        const isMuted = audioManager.toggleMute();
        this.audioBtn.textContent = isMuted ? 'Unmute Audio' : 'Mute Audio';
        updateAudioButton();
      }

      goHome() {
        this.resume();
        gameRunning = false;
        audioManager.stopBackgroundMusic();
        showHomeScreen();
        setTimeout(() => {
          audioManager.restartBackgroundMusic();
        }, 500);
      }

      show() {
        this.pauseBtn.style.display = 'block';
      }

      hide() {
        this.pauseBtn.style.display = 'none';
      }

      reset() {
        this.isPaused = false;
        this.pauseBtn.innerHTML = '<i class="fas fa-pause"></i> PAUSE';
        this.pauseBtn.classList.remove('paused');
        this.pauseOverlay.style.display = 'none';
      }
    }

    // Initialize pause manager
    const pauseManager = new PauseManager();

    // Audio button functionality
    const audioBtn = document.getElementById('audio-btn');
    
    function updateAudioButton() {
      const isMuted = audioManager.getMutedState();
      audioBtn.innerHTML = isMuted ? '<i class="fas fa-volume-mute"></i> AUDIO' : '<i class="fas fa-volume-up"></i> AUDIO';
      audioBtn.classList.toggle('muted', isMuted);
    }

    audioBtn.addEventListener('click', () => {
      audioManager.toggleMute();
      updateAudioButton();
    });

    // Initialize audio button
    updateAudioButton();

    // Loading screen
    let loadingProgress = 0;
    const loadingProgressBar = document.getElementById('loading-progress');
    const loadingScreen = document.getElementById('loading-screen');
    const homeScreen = document.getElementById('home-screen');
    const trailScreen = document.getElementById('trail-screen');
    const difficultyScreen = document.getElementById('difficulty-screen');
    const customizationScreen = document.getElementById('customization-screen');
    const controlCustomizationScreen = document.getElementById('control-customization-screen');

    function updateLoadingProgress() {
      loadingProgress += Math.random() * 15 + 5;
      loadingProgressBar.style.width = Math.min(loadingProgress, 100) + '%';
      
      if (loadingProgress >= 100) {
        setTimeout(() => {
          loadingScreen.style.display = 'none';
          showHomeScreen();
        }, 500);
      } else {
        setTimeout(updateLoadingProgress, 100);
      }
    }

    function showHomeScreen() {
      homeScreen.style.display = 'flex';
      trailScreen.style.display = 'none';
      difficultyScreen.style.display = 'none';
      customizationScreen.style.display = 'none';
      controlCustomizationScreen.style.display = 'none';
      document.getElementById('game-over-screen').style.display = 'none';
      fullscreenManager.hide();
      pauseManager.hide();
      audioBtn.style.display = 'none';
      
      // Show mobile control customization button only on mobile
      const controlsBtn = document.getElementById('home-controls-btn');
      if (isMobile) {
        controlsBtn.style.display = 'block';
      } else {
        controlsBtn.style.display = 'none';
      }
      
      // Update displays with current values
      highScoreManager.initializeDisplays();
      
      audioManager.restartBackgroundMusic();
    }

    function hideHomeScreen() {
      homeScreen.style.display = 'none';
    }

    function showTrailScreen() {
      hideHomeScreen();
      trailScreen.style.display = 'flex';
      initializeTrailCustomization();
    }

    function hideTrailScreen() {
      trailScreen.style.display = 'none';
    }

    function showDifficultyScreen() {
      hideHomeScreen();
      difficultyScreen.style.display = 'flex';
    }

    function hideDifficultyScreen() {
      difficultyScreen.style.display = 'none';
    }

    function showCustomizationScreen() {
      hideHomeScreen();
      customizationScreen.style.display = 'flex';
      initializeShipCustomization();
    }

    function hideCustomizationScreen() {
      customizationScreen.style.display = 'none';
      fullscreenManager.show();
      pauseManager.show();
      audioBtn.style.display = 'block';
      resizeCanvas();
      initGame();
      
      audioManager.restartBackgroundMusic();
      
      setTimeout(() => {
        fullscreenManager.autoEnterFullscreen();
      }, 500);
    }

    function showControlCustomizationScreen() {
      hideHomeScreen();
      controlCustomizationScreen.style.display = 'flex';
      initializeControlCustomization();
    }

    function hideControlCustomizationScreen() {
      controlCustomizationScreen.style.display = 'none';
    }

    // Home screen event listeners
    document.getElementById('home-start-btn').addEventListener('click', showCustomizationScreen);
    document.getElementById('home-customize-btn').addEventListener('click', showCustomizationScreen);
    document.getElementById('home-trail-btn').addEventListener('click', showTrailScreen);
    document.getElementById('home-difficulty-btn').addEventListener('click', showDifficultyScreen);
    document.getElementById('home-controls-btn').addEventListener('click', showControlCustomizationScreen);

    // Control customization functions
    function initializeControlCustomization() {
      const settings = mobileControlManager.settings;
      
      // Set slider values
      document.getElementById('joystick-size').value = settings.joystick.size;
      document.getElementById('joystick-x').value = settings.joystick.x;
      document.getElementById('joystick-y').value = settings.joystick.y;
      document.getElementById('shoot-size').value = settings.shoot.size;
      document.getElementById('shoot-x').value = settings.shoot.x;
      document.getElementById('shoot-y').value = settings.shoot.y;
      
      // Update display values
      updateControlDisplayValues();
      
      // Add event listeners to sliders
      const sliders = document.querySelectorAll('.control-slider');
      sliders.forEach(slider => {
        slider.addEventListener('input', handleSliderChange);
      });
    }

    function updateControlDisplayValues() {
      document.getElementById('joystick-size-value').textContent = document.getElementById('joystick-size').value + 'px';
      document.getElementById('joystick-x-value').textContent = document.getElementById('joystick-x').value + '%';
      document.getElementById('joystick-y-value').textContent = document.getElementById('joystick-y').value + '%';
      document.getElementById('shoot-size-value').textContent = document.getElementById('shoot-size').value + 'px';
      document.getElementById('shoot-x-value').textContent = document.getElementById('shoot-x').value + '%';
      document.getElementById('shoot-y-value').textContent = document.getElementById('shoot-y').value + '%';
    }

    function handleSliderChange(event) {
      const sliderId = event.target.id;
      const value = parseFloat(event.target.value);
      
      // Update display
      updateControlDisplayValues();
      
      // Apply setting
      if (sliderId.startsWith('joystick-')) {
        const property = sliderId.replace('joystick-', '');
        mobileControlManager.updateSetting('joystick', property, value);
      } else if (sliderId.startsWith('shoot-')) {
        const property = sliderId.replace('shoot-', '');
        mobileControlManager.updateSetting('shoot', property, value);
      }
    }

    // Control customization event listeners
    document.getElementById('save-controls-btn').addEventListener('click', () => {
      mobileControlManager.saveControlSettings();
      hideControlCustomizationScreen();
      showHomeScreen();
    });

    document.getElementById('reset-controls-btn').addEventListener('click', () => {
      mobileControlManager.resetToDefaults();
      initializeControlCustomization();
    });

    document.getElementById('back-to-home-controls-btn').addEventListener('click', () => {
      hideControlCustomizationScreen();
      showHomeScreen();
    });

    // Enhanced trail customization with types
    function initializeTrailCustomization() {
      const colorOptions = document.querySelectorAll('.color-option');
      const typeButtons = document.querySelectorAll('.trail-type-btn');
      const trailCanvas = document.getElementById('trail-preview-canvas');
      const trailCtx = trailCanvas.getContext('2d');
      
      // Set current selections
      const currentColor = trailEffectManager.getCurrentColor();
      const currentType = trailEffectManager.getCurrentType();
      
      colorOptions.forEach(option => {
        option.classList.remove('selected');
        if (option.dataset.color === currentColor) {
          option.classList.add('selected');
        }
      });
      
      typeButtons.forEach(button => {
        button.classList.remove('active');
        if (button.dataset.type === currentType) {
          button.classList.add('active');
        }
      });
      
      // Add click handlers
      colorOptions.forEach(option => {
        option.addEventListener('click', () => {
          colorOptions.forEach(opt => opt.classList.remove('selected'));
          option.classList.add('selected');
          updateTrailPreview(option.dataset.color, trailEffectManager.getCurrentType());
        });
      });
      
      typeButtons.forEach(button => {
        button.addEventListener('click', () => {
          typeButtons.forEach(btn => btn.classList.remove('active'));
          button.classList.add('active');
          updateTrailPreview(trailEffectManager.getCurrentColor(), button.dataset.type);
        });
      });
      
      updateTrailPreview(currentColor, currentType);
    }

    function updateTrailPreview(color, type) {
      const trailCanvas = document.getElementById('trail-preview-canvas');
      const trailCtx = trailCanvas.getContext('2d');
      
      // Clear canvas
      trailCtx.fillStyle = 'rgba(0, 20, 40, 0.8)';
      trailCtx.fillRect(0, 0, trailCanvas.width, trailCanvas.height);
      
      const centerX = trailCanvas.width / 2;
      const centerY = trailCanvas.height / 2;
      
      // Draw ship
      trailCtx.save();
      trailCtx.translate(centerX + 50, centerY);
      trailCtx.fillStyle = '#00ffff';
      trailCtx.shadowBlur = 10;
      trailCtx.shadowColor = '#00ffff';
      trailCtx.beginPath();
      trailCtx.moveTo(15, 0);
      trailCtx.lineTo(-10, -8);
      trailCtx.lineTo(-5, 0);
      trailCtx.lineTo(-10, 8);
      trailCtx.closePath();
      trailCtx.fill();
      trailCtx.restore();
      
      // Draw trail based on type
      for (let i = 0; i < 20; i++) {
        const x = centerX + 50 - i * 8 - Math.random() * 10;
        const y = centerY + (Math.random() - 0.5) * 20;
        const alpha = 1 - (i / 20);
        const size = 3 + Math.random() * 3;
        
        trailCtx.save();
        trailCtx.globalAlpha = alpha;
        trailCtx.fillStyle = color;
        trailCtx.shadowBlur = 8;
        trailCtx.shadowColor = color;
        
        switch (type) {
          case 'sparkles':
            // Draw star shape
            trailCtx.beginPath();
            for (let j = 0; j < 5; j++) {
              const angle = (j * Math.PI * 2) / 5;
              const outerRadius = size;
              const innerRadius = size * 0.4;
              const xOuter = x + Math.cos(angle) * outerRadius;
              const yOuter = y + Math.sin(angle) * outerRadius;
              const xInner = x + Math.cos(angle + Math.PI / 5) * innerRadius;
              const yInner = y + Math.sin(angle + Math.PI / 5) * innerRadius;
              
              if (j === 0) {
                trailCtx.moveTo(xOuter, yOuter);
              } else {
                trailCtx.lineTo(xOuter, yOuter);
              }
              trailCtx.lineTo(xInner, yInner);
            }
            trailCtx.closePath();
            trailCtx.fill();
            break;
            
          case 'smoke':
            // Draw irregular clouds
            trailCtx.beginPath();
            for (let j = 0; j < 6; j++) {
              const angle = (j * Math.PI * 2) / 6;
              const radius = size * (0.8 + Math.random() * 0.4);
              const px = x + Math.cos(angle) * radius;
              const py = y + Math.sin(angle) * radius;
              if (j === 0) {
                trailCtx.moveTo(px, py);
              } else {
                trailCtx.lineTo(px, py);
              }
            }
            trailCtx.closePath();
            trailCtx.fill();
            break;
            
          case 'energy':
            // Draw diamond shape
            trailCtx.beginPath();
            trailCtx.moveTo(x, y - size);
            trailCtx.lineTo(x + size, y);
            trailCtx.lineTo(x, y + size);
            trailCtx.lineTo(x - size, y);
            trailCtx.closePath();
            trailCtx.fill();
            break;
            
          default: // particles
            trailCtx.beginPath();
            trailCtx.arc(x, y, size, 0, Math.PI * 2);
            trailCtx.fill();
            break;
        }
        
        trailCtx.restore();
      }
    }

    // Trail screen event listeners
    document.getElementById('save-trail-btn').addEventListener('click', () => {
      const selectedColor = document.querySelector('.color-option.selected');
      const selectedType = document.querySelector('.trail-type-btn.active');
      
      if (selectedColor) {
        trailEffectManager.setColor(selectedColor.dataset.color);
      }
      if (selectedType) {
        trailEffectManager.setType(selectedType.dataset.type);
      }
      
      hideTrailScreen();
      showHomeScreen();
    });

    document.getElementById('back-to-home-trail-btn').addEventListener('click', () => {
      hideTrailScreen();
      showHomeScreen();
    });

    // Start loading
    updateLoadingProgress();

    // Game variables
    const canvas = document.getElementById("game");
    const ctx = canvas.getContext("2d");

    let mouse = { x: 0, y: 0 };
    let keys = {};
    let lives = 3;
    let score = 0;
    let powerUps = [];
    let particles = [];
    let explosions = [];
    let enemyBullets = [];
    let shieldActive = false;
    let shieldTimer = 0;
    let gameRunning = false;
    let animationFrameId;
    let currentLives = 3;
    let selectedShip = 'striker';
    let currentBoss = null;
    let bossActive = false;
    let enemiesKilled = 0;
    let nextBossAt = 20;
    const maxLives = 6;

    // Enhanced Ship configurations with 2 new ships
    const shipConfigs = {
      striker: {
        name: 'Cyber Striker',
        theme: 'Cyber Blue',
        speed: 85,
        power: 70,
        defense: 60,
        speedMultiplier: 1.0,
        powerMultiplier: 1.0,
        defenseMultiplier: 1.0,
        colors: {
          primary: '#00ffff',
          secondary: '#0080ff',
          accent: '#ffffff'
        }
      },
      hunter: {
        name: 'Plasma Hunter',
        theme: 'Plasma Red',
        speed: 90,
        power: 85,
        defense: 50,
        speedMultiplier: 1.1,
        powerMultiplier: 1.2,
        defenseMultiplier: 0.9,
        colors: {
          primary: '#ff4444',
          secondary: '#cc0000',
          accent: '#ffaaaa'
        }
      },
      guardian: {
        name: 'Void Guardian',
        theme: 'Void Purple',
        speed: 60,
        power: 60,
        defense: 95,
        speedMultiplier: 0.8,
        powerMultiplier: 0.9,
        defenseMultiplier: 1.3,
        colors: {
          primary: '#aa44ff',
          secondary: '#6600aa',
          accent: '#ddaaff'
        }
      },
      interceptor: {
        name: 'Solar Interceptor',
        theme: 'Solar Gold',
        speed: 100,
        power: 75,
        defense: 40,
        speedMultiplier: 1.3,
        powerMultiplier: 1.1,
        defenseMultiplier: 0.7,
        colors: {
          primary: '#ffdd00',
          secondary: '#cc9900',
          accent: '#ffff88'
        }
      },
      phantom: {
        name: 'Stealth Phantom',
        theme: 'Shadow Black',
        speed: 95,
        power: 80,
        defense: 65,
        speedMultiplier: 1.2,
        powerMultiplier: 1.15,
        defenseMultiplier: 1.0,
        colors: {
          primary: '#444444',
          secondary: '#222222',
          accent: '#888888'
        }
      },
      vanguard: {
        name: 'Crystal Vanguard',
        theme: 'Crystal White',
        speed: 70,
        power: 95,
        defense: 85,
        speedMultiplier: 0.9,
        powerMultiplier: 1.4,
        defenseMultiplier: 1.2,
        colors: {
          primary: '#ffffff',
          secondary: '#cccccc',
          accent: '#aaffff'
        }
      }
    };

    const scoreSpan = document.getElementById("score");
    const highScoreSpan = document.getElementById("high-score");
    const shieldTimeSpan = document.getElementById("shield-time");
    const difficultyDisplay = document.getElementById("difficulty-display");
    const shipNameDisplay = document.getElementById("ship-name-display");
    const gameOverScreen = document.getElementById("game-over-screen");
    const finalScoreSpan = document.getElementById("final-score");
    const highScoreMessage = document.getElementById("high-score-message");
    const restartButton = document.getElementById("restart-button");
    const customizeButton = document.getElementById("customize-button");
    const difficultyButton = document.getElementById("difficulty-button");
    const homeButton = document.getElementById("home-button");
    const mobileControlsDiv = document.getElementById("mobile-controls");
    const joystickContainer = document.getElementById("joystick-container");
    const joystick = document.getElementById("joystick");
    const shootButton = document.getElementById("shoot-button");
    const easyBtn = document.getElementById("easy-btn");
    const mediumBtn = document.getElementById("medium-btn");
    const hardBtn = document.getElementById("hard-btn");
    const bossHealthContainer = document.getElementById("boss-health-container");
    const bossHealthFill = document.getElementById("boss-health-fill");
    const bossName = document.getElementById("boss-name");
    const bossWarning = document.getElementById("boss-warning");

    // Store original boss health for regeneration
    let originalBossHealth = 0;

    // Initialize high score display
    highScoreManager.initializeDisplays();

    // Enhanced Difficulty selection with Medium mode
    easyBtn.addEventListener('click', () => {
      difficultyManager.setDifficulty('easy');
      updateDifficultyDisplay();
      hideDifficultyScreen();
      showCustomizationScreen();
    });

    mediumBtn.addEventListener('click', () => {
      difficultyManager.setDifficulty('medium');
      updateDifficultyDisplay();
      hideDifficultyScreen();
      showCustomizationScreen();
    });

    hardBtn.addEventListener('click', () => {
      difficultyManager.setDifficulty('hard');
      updateDifficultyDisplay();
      hideDifficultyScreen();
      showCustomizationScreen();
    });

    document.getElementById('back-to-home-difficulty-btn').addEventListener('click', () => {
      hideDifficultyScreen();
      showHomeScreen();
    });

    function updateDifficultyDisplay() {
      const config = difficultyManager.getCurrentConfig();
      difficultyDisplay.textContent = config.name;
      difficultyDisplay.className = `hud-value ${config.className}`;
    }

    // Ship customization
    function initializeShipCustomization() {
      const shipGrid = document.getElementById('ship-grid');
      const previewCanvas = document.getElementById('preview-canvas');
      const previewCtx = previewCanvas.getContext('2d');
      
      shipGrid.innerHTML = '';
      
      Object.keys(shipConfigs).forEach(shipKey => {
        const config = shipConfigs[shipKey];
        const shipOption = document.createElement('div');
        shipOption.className = 'ship-option';
        if (shipKey === selectedShip) {
          shipOption.classList.add('selected');
        }
        
        shipOption.innerHTML = `
          <canvas class="mini-ship-canvas" width="120" height="80"></canvas>
          <h4>${config.name}</h4>
          <div class="ship-theme">${config.theme}</div>
        `;
        
        const miniCanvas = shipOption.querySelector('.mini-ship-canvas');
        const miniCtx = miniCanvas.getContext('2d');
        drawShipPreview(miniCtx, 60, 40, shipKey, 0.7);
        
        shipOption.addEventListener('click', () => {
          document.querySelectorAll('.ship-option').forEach(opt => opt.classList.remove('selected'));
          shipOption.classList.add('selected');
          selectedShip = shipKey;
          updateShipPreview();
        });
        
        shipGrid.appendChild(shipOption);
      });
      
      updateShipPreview();
    }

    function updateShipPreview() {
      const previewCanvas = document.getElementById('preview-canvas');
      const previewCtx = previewCanvas.getContext('2d');
      const config = shipConfigs[selectedShip];
      
      // Clear canvas
      previewCtx.fillStyle = 'rgba(0, 20, 40, 0.8)';
      previewCtx.fillRect(0, 0, previewCanvas.width, previewCanvas.height);
      
      // Draw ship
      drawShipPreview(previewCtx, 100, 75, selectedShip, 1.5);
      
      // Update stats
      document.getElementById('speed-stat').style.width = config.speed + '%';
      document.getElementById('power-stat').style.width = config.power + '%';
      document.getElementById('defense-stat').style.width = config.defense + '%';
      
      // Update ship name in HUD
      shipNameDisplay.textContent = config.name.toUpperCase();
    }

    function drawShipPreview(ctx, x, y, shipType, scale = 1) {
      const config = shipConfigs[shipType];
      ctx.save();
      ctx.translate(x, y);
      ctx.scale(scale, scale);
      
      ctx.shadowBlur = 10;
      ctx.shadowColor = config.colors.primary;
      
      if (shipType === 'striker') {
        // Cyber Striker - Angular design
        ctx.fillStyle = config.colors.primary;
        ctx.beginPath();
        ctx.moveTo(20, 0);
        ctx.lineTo(-15, -10);
        ctx.lineTo(-10, -6);
        ctx.lineTo(-10, 6);
        ctx.lineTo(-15, 10);
        ctx.closePath();
        ctx.fill();
        
        ctx.fillStyle = config.colors.secondary;
        ctx.beginPath();
        ctx.moveTo(-10, -6);
        ctx.lineTo(-15, -10);
        ctx.lineTo(-10, -8);
        ctx.closePath();
        ctx.fill();
        
        ctx.beginPath();
        ctx.moveTo(-10, 6);
        ctx.lineTo(-15, 10);
        ctx.lineTo(-10, 8);
        ctx.closePath();
        ctx.fill();
        
      } else if (shipType === 'hunter') {
        // Plasma Hunter - Aggressive design
        ctx.fillStyle = config.colors.primary;
        ctx.beginPath();
        ctx.moveTo(22, 0);
        ctx.lineTo(-12, -12);
        ctx.lineTo(-18, -8);
        ctx.lineTo(-8, 0);
        ctx.lineTo(-18, 8);
        ctx.lineTo(-12, 12);
        ctx.closePath();
        ctx.fill();
        
        ctx.fillStyle = config.colors.secondary;
        ctx.beginPath();
        ctx.moveTo(15, -4);
        ctx.lineTo(18, 0);
        ctx.lineTo(15, 4);
        ctx.closePath();
        ctx.fill();
        
      } else if (shipType === 'guardian') {
        // Void Guardian - Bulky design
        ctx.fillStyle = config.colors.primary;
        ctx.beginPath();
        ctx.moveTo(18, 0);
        ctx.lineTo(-16, -14);
        ctx.lineTo(-20, -10);
        ctx.lineTo(-20, 10);
        ctx.lineTo(-16, 14);
        ctx.closePath();
        ctx.fill();
        
        ctx.fillStyle = config.colors.secondary;
        ctx.beginPath();
        ctx.arc(0, 0, 8, 0, Math.PI * 2);
        ctx.fill();
        
      } else if (shipType === 'interceptor') {
        // Solar Interceptor - Sleek design
        ctx.fillStyle = config.colors.primary;
        ctx.beginPath();
        ctx.moveTo(25, 0);
        ctx.lineTo(-18, -8);
        ctx.lineTo(-12, -4);
        ctx.lineTo(-12, 4);
        ctx.lineTo(-18, 8);
        ctx.closePath();
        ctx.fill();
        
        ctx.fillStyle = config.colors.secondary;
        ctx.beginPath();
        ctx.moveTo(20, -2);
        ctx.lineTo(15, 0);
        ctx.lineTo(20, 2);
        ctx.closePath();
        ctx.fill();
        
      } else if (shipType === 'phantom') {
        // Stealth Phantom - Stealthy angular design
        ctx.fillStyle = config.colors.primary;
        ctx.beginPath();
        ctx.moveTo(24, 0);
        ctx.lineTo(-14, -8);
        ctx.lineTo(-20, -6);
        ctx.lineTo(-16, -2);
        ctx.lineTo(-16, 2);
        ctx.lineTo(-20, 6);
        ctx.lineTo(-14, 8);
        ctx.closePath();
        ctx.fill();
        
        // Shadow accents
        ctx.fillStyle = config.colors.secondary;
        ctx.beginPath();
        ctx.moveTo(16, -3);
        ctx.lineTo(20, 0);
        ctx.lineTo(16, 3);
        ctx.lineTo(12, 0);
        ctx.closePath();
        ctx.fill();
        
        // Wing details
        ctx.fillStyle = config.colors.accent;
        ctx.beginPath();
        ctx.moveTo(-12, -6);
        ctx.lineTo(-8, -4);
        ctx.lineTo(-8, 4);
        ctx.lineTo(-12, 6);
        ctx.closePath();
        ctx.fill();
        
      } else if (shipType === 'vanguard') {
        // Crystal Vanguard - Crystalline design
        ctx.fillStyle = config.colors.primary;
        ctx.beginPath();
        ctx.moveTo(20, 0);
        ctx.lineTo(-12, -12);
        ctx.lineTo(-18, -8);
        ctx.lineTo(-14, -4);
        ctx.lineTo(-14, 4);
        ctx.lineTo(-18, 8);
        ctx.lineTo(-12, 12);
        ctx.closePath();
        ctx.fill();
        
        // Crystal facets
        ctx.fillStyle = config.colors.accent;
        ctx.beginPath();
        ctx.moveTo(15, -6);
        ctx.lineTo(18, 0);
        ctx.lineTo(15, 6);
        ctx.lineTo(8, 3);
        ctx.lineTo(8, -3);
        ctx.closePath();
        ctx.fill();
        
        // Inner crystal
        ctx.fillStyle = config.colors.secondary;
        ctx.beginPath();
        ctx.moveTo(12, -4);
        ctx.lineTo(14, 0);
        ctx.lineTo(12, 4);
        ctx.lineTo(6, 2);
        ctx.lineTo(6, -2);
        ctx.closePath();
        ctx.fill();
      }
      
      // Cockpit
      ctx.fillStyle = config.colors.accent;
      ctx.beginPath();
      ctx.arc(3, 0, 3, 0, Math.PI * 2);
      ctx.fill();
      
      ctx.restore();
    }

    // Customization event listeners
    document.getElementById('start-game-btn').addEventListener('click', hideCustomizationScreen);
    document.getElementById('back-to-home-customization-btn').addEventListener('click', () => {
      customizationScreen.style.display = 'none';
      showHomeScreen();
    });

    // Heart system functions
    function createHearts() {
      const container = document.getElementById('hearts-container');
      if (!container) return;
      
      container.innerHTML = '';
      
      for (let i = 0; i < maxLives; i++) {
        const heart = document.createElement('div');
        heart.className = 'hexagon-heart';
        heart.id = `heart-${i}`;
        
        if (i < currentLives) {
          heart.classList.add('filled');
        } else {
          heart.classList.add('empty');
        }
        
        container.appendChild(heart);
      }
    }

    function setLives(newLives, animated = true) {
      const oldLives = currentLives;
      currentLives = Math.max(0, Math.min(maxLives, newLives));
      lives = currentLives;
      
      if (!animated) {
        createHearts();
        return;
      }
      
      if (currentLives < oldLives) {
        // Damage animation
        for (let i = 0; i < maxLives; i++) {
          const heart = document.getElementById(`heart-${i}`);
          if (heart) {
            heart.classList.add('damage-animation');
            setTimeout(() => {
              heart.classList.remove('damage-animation');
            }, 600);
          }
        }
        
        for (let i = oldLives - 1; i >= currentLives; i--) {
          const heart = document.getElementById(`heart-${i}`);
          if (heart) {
            heart.classList.add('losing-life');
            setTimeout(() => {
              heart.classList.remove('losing-life', 'filled');
              heart.classList.add('empty');
            }, 500);
          }
        }
      }
      
      if (currentLives > oldLives) {
        // Heal animation
        for (let i = oldLives; i < currentLives; i++) {
          const heart = document.getElementById(`heart-${i}`);
          if (heart) {
            heart.classList.add('heal-animation', 'gaining-life');
            setTimeout(() => {
              heart.classList.remove('gaining-life', 'empty');
              heart.classList.add('filled');
            }, 100);
            
            setTimeout(() => {
              heart.classList.remove('heal-animation');
              if (i >= 3) {
                heart.classList.add('powerup-glow');
                setTimeout(() => {
                  heart.classList.remove('powerup-glow');
                }, 800);
              }
            }, 800);
          }
        }
      }
    }

    // Canvas and responsiveness with optimized performance
    function resizeCanvas() {
      const pixelRatio = Math.min(window.devicePixelRatio || 1, 2);
      canvas.width = window.innerWidth * pixelRatio;
      canvas.height = window.innerHeight * pixelRatio;
      canvas.style.width = window.innerWidth + 'px';
      canvas.style.height = window.innerHeight + 'px';
      ctx.scale(pixelRatio, pixelRatio);
      
      if (ship) {
        ship.x = window.innerWidth / 2;
        ship.y = window.innerHeight / 2;
        if (!isMobile) {
          mouse.x = ship.x;
          mouse.y = ship.y;
        }
      }
      createStars();
    }

    window.addEventListener('resize', resizeCanvas);

    // Enhanced star generation with mobile optimization
    let stars = [];
    function createStars() {
      stars = [];
      const baseStarCount = isMobile ? 80 : 150; // Further reduced for mobile performance
      const starCount = Math.min(baseStarCount, Math.floor((window.innerWidth * window.innerHeight) / (isMobile ? 10000 : 6000)));
      for (let i = 0; i < starCount; i++) {
        stars.push({
          x: Math.random() * window.innerWidth,
          y: Math.random() * window.innerHeight,
          size: Math.random() * 3,
          speed: Math.random() * 0.8 + 0.2,
          twinkle: Math.random() * Math.PI * 2,
          color: Math.random() > 0.8 ? '#00ffff' : '#ffffff'
        });
      }
    }

    // Enhanced Trail Particle Classes
    class Particle {
      constructor(x, y, angle, speed, color = null, size = null, type = 'normal') {
        this.x = x;
        this.y = y;
        this.velX = Math.cos(angle) * speed;
        this.velY = Math.sin(angle) * speed;
        this.alpha = 1;
        this.size = size || Math.random() * 6 + 2;
        this.color = color || `hsl(${Math.random() * 60 + 10}, 100%, 50%)`;
        this.life = 1;
        this.decay = type === 'thruster' ? 0.015 : 0.02;
        this.gravity = type === 'thruster' ? 0.005 : 0.01;
        this.active = true;
        this.type = type;
        this.initialSize = this.size;
      }

      update() {
        if (!this.active) return;
        this.x += this.velX;
        this.y += this.velY;
        
        if (this.type === 'thruster') {
          this.velY += this.gravity * 0.5;
          this.velX *= 0.98;
          this.size = this.initialSize * this.life;
        } else {
          this.velY += this.gravity;
          this.size *= 0.98;
        }
        
        this.alpha -= this.decay;
        this.life -= this.decay;
        if (this.life <= 0) this.active = false;
      }

      draw() {
        if (!this.active) return;
        ctx.save();
        ctx.globalAlpha = this.alpha;
        ctx.fillStyle = this.color;
        
        if (this.type === 'thruster') {
          ctx.shadowBlur = 15;
          ctx.shadowColor = this.color;
        } else {
          ctx.shadowBlur = 10;
          ctx.shadowColor = this.color;
        }
        
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size / 2, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
      }
    }

    // Sparkle Particle Class
    class SparkleParticle extends Particle {
      constructor(x, y, angle, speed, color, size) {
        super(x, y, angle, speed, color, size, 'sparkle');
        this.rotation = 0;
        this.rotationSpeed = (Math.random() - 0.5) * 0.2;
      }

      update() {
        super.update();
        this.rotation += this.rotationSpeed;
      }

      draw() {
        if (!this.active) return;
        ctx.save();
        ctx.globalAlpha = this.alpha;
        ctx.fillStyle = this.color;
        ctx.shadowBlur = 15;
        ctx.shadowColor = this.color;
        ctx.translate(this.x, this.y);
        ctx.rotate(this.rotation);
        
        // Draw star shape
        ctx.beginPath();
        for (let i = 0; i < 5; i++) {
          const angle = (i * Math.PI * 2) / 5;
          const outerRadius = this.size / 2;
          const innerRadius = this.size * 0.2;
          const xOuter = Math.cos(angle) * outerRadius;
          const yOuter = Math.sin(angle) * outerRadius;
          const xInner = Math.cos(angle + Math.PI / 5) * innerRadius;
          const yInner = Math.sin(angle + Math.PI / 5) * innerRadius;
          
          if (i === 0) {
            ctx.moveTo(xOuter, yOuter);
          } else {
            ctx.lineTo(xOuter, yOuter);
          }
          ctx.lineTo(xInner, yInner);
        }
        ctx.closePath();
        ctx.fill();
        ctx.restore();
      }
    }

    // Smoke Particle Class
    class SmokeParticle extends Particle {
      constructor(x, y, angle, speed, color, size) {
        super(x, y, angle, speed, color, size, 'smoke');
        this.expansion = 1.05;
      }

      update() {
        super.update();
        this.size *= this.expansion;
        this.velX *= 0.95;
        this.velY *= 0.95;
      }

      draw() {
        if (!this.active) return;
        ctx.save();
        ctx.globalAlpha = this.alpha * 0.7;
        ctx.fillStyle = this.color;
        ctx.shadowBlur = 20;
        ctx.shadowColor = this.color;
        
        // Draw irregular cloud shape
        ctx.beginPath();
        for (let i = 0; i < 6; i++) {
          const angle = (i * Math.PI * 2) / 6;
          const radius = (this.size / 2) * (0.8 + Math.random() * 0.4);
          const px = this.x + Math.cos(angle) * radius;
          const py = this.y + Math.sin(angle) * radius;
          if (i === 0) {
            ctx.moveTo(px, py);
          } else {
            ctx.lineTo(px, py);
          }
        }
        ctx.closePath();
        ctx.fill();
        ctx.restore();
      }
    }

    // Energy Particle Class
    class EnergyParticle extends Particle {
      constructor(x, y, angle, speed, color, size) {
        super(x, y, angle, speed, color, size, 'energy');
        this.pulsePhase = Math.random() * Math.PI * 2;
      }

      update() {
        super.update();
        this.pulsePhase += 0.3;
      }

      draw() {
        if (!this.active) return;
        const pulse = Math.sin(this.pulsePhase) * 0.3 + 1;
        
        ctx.save();
        ctx.globalAlpha = this.alpha;
        ctx.fillStyle = this.color;
        ctx.shadowBlur = 20 * pulse;
        ctx.shadowColor = this.color;
        
        // Draw diamond shape
        const size = (this.size / 2) * pulse;
        ctx.beginPath();
        ctx.moveTo(this.x, this.y - size);
        ctx.lineTo(this.x + size, this.y);
        ctx.lineTo(this.x, this.y + size);
        ctx.lineTo(this.x - size, this.y);
        ctx.closePath();
        ctx.fill();
        ctx.restore();
      }
    }

    // Enhanced Explosion class
    class Explosion {
      constructor(x, y, size = 50) {
        this.x = x;
        this.y = y;
        this.size = size;
        this.maxSize = size;
        this.life = 1;
        this.particles = [];
        this.active = true;
        
        // Create explosion particles - reduce count on mobile
        const particleCount = isMobile ? 10 : 15;
        for (let i = 0; i < particleCount; i++) {
          const angle = (Math.PI * 2 * i) / particleCount;
          const speed = Math.random() * 8 + 4;
          this.particles.push(new Particle(x, y, angle, speed, '#ff4444', 8));
        }
      }

      update() {
        if (!this.active) return;
        this.life -= 0.05;
        this.size = this.maxSize * this.life;
        
        for (let i = this.particles.length - 1; i >= 0; i--) {
          this.particles[i].update();
          if (!this.particles[i].active) {
            this.particles.splice(i, 1);
          }
        }
        
        if (this.life <= 0) this.active = false;
      }

      draw() {
        if (!this.active) return;
        // Draw explosion ring
        ctx.save();
        ctx.globalAlpha = this.life;
        
        const gradient = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, this.size);
        gradient.addColorStop(0, 'rgba(255, 255, 255, 0.8)');
        gradient.addColorStop(0.4, 'rgba(255, 100, 100, 0.6)');
        gradient.addColorStop(1, 'rgba(255, 0, 0, 0)');
        
        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
        
        // Draw particles
        for (let particle of this.particles) {
          particle.draw();
        }
      }
    }

    // Enhanced Ship class with mobile speed boost
    class Ship {
      constructor() {
        this.x = window.innerWidth / 2;
        this.y = window.innerHeight / 2;
        this.angle = 0;
        this.vel = { x: 0, y: 0 };
        this.radius = 20;
        this.doubleShot = false;
        this.doubleTimer = 0;
        this.lastShot = 0;
        this.shootCooldown = 150;
        this.active = true;
        this.thrusterParticles = [];
      }

      update() {
        if (!gameRunning || !this.active) return;

        let thrusting = false;
        const config = shipConfigs[selectedShip];
        
        // Mobile speed boost (20% increase)
        const mobileSpeedBoost = isMobile ? 1.2 : 1.0;

        if (!isMobile) {
          this.angle = Math.atan2(mouse.y - this.y, mouse.x - this.x);
          if (keys["w"] || keys["W"]) {
            this.vel.x += Math.cos(this.angle) * 0.3 * config.speedMultiplier * mobileSpeedBoost;
            this.vel.y += Math.sin(this.angle) * 0.3 * config.speedMultiplier * mobileSpeedBoost;
            thrusting = true;
          }
        } else {
          // Enhanced mobile joystick movement with speed boost
          const joystickRect = joystick.getBoundingClientRect();
          const joystickContainerRect = joystickContainer.getBoundingClientRect();

          const joystickCenterX = joystickContainerRect.left + joystickContainerRect.width / 2;
          const joystickCenterY = joystickContainerRect.top + joystickContainerRect.height / 2;
          
          const currentJoystickX = joystickRect.left + joystickRect.width / 2;
          const currentJoystickY = joystickRect.top + joystickRect.height / 2;

          const dxJoy = currentJoystickX - joystickCenterX;
          const dyJoy = currentJoystickY - joystickCenterY;

          if (Math.hypot(dxJoy, dyJoy) > 10) { 
            this.angle = Math.atan2(dyJoy, dxJoy);
            // Mobile speed with 20% boost
            const mobileSpeedMultiplier = (isIOS ? 0.15 : 0.18) * mobileSpeedBoost;
            this.vel.x += Math.cos(this.angle) * mobileSpeedMultiplier * config.speedMultiplier;
            this.vel.y += Math.sin(this.angle) * mobileSpeedMultiplier * config.speedMultiplier;
            thrusting = true;
          }
        }

        // Apply friction
        this.vel.x *= 0.95;
        this.vel.y *= 0.95;
        
        // Update position
        this.x += this.vel.x;
        this.y += this.vel.y;

        // Enhanced thruster particles with custom trail effects - reduce on mobile
        if (thrusting) {
          const particleCount = isMobile ? 1 : 3;
          for (let i = 0; i < particleCount; i++) {
            const offsetAngle = this.angle + Math.PI + (Math.random() - 0.5) * 0.6;
            const speed = Math.random() * 6 + 3;
            const distance = 25 + Math.random() * 15;
            
            const trailParticle = trailEffectManager.createTrailParticle(
              this.x - Math.cos(this.angle) * distance,
              this.y - Math.sin(this.angle) * distance,
              offsetAngle,
              speed,
              Math.random() * 4 + 2
            );
            
            particles.push(trailParticle);
          }
        }

        // Update stars parallax effect
        for (let star of stars) {
          star.x -= this.vel.x * star.speed * 0.5;
          star.y -= this.vel.y * star.speed * 0.5;
          star.twinkle += 0.1;
          
          if (star.x < -10) star.x = window.innerWidth + 10;
          if (star.x > window.innerWidth + 10) star.x = -10;
          if (star.y < -10) star.y = window.innerHeight + 10;
          if (star.y > window.innerHeight + 10) star.y = -10;
        }

        // Screen wrapping
        if (this.x < 0) this.x = window.innerWidth;
        if (this.x > window.innerWidth) this.x = 0;
        if (this.y < 0) this.y = window.innerHeight;
        if (this.y > window.innerHeight) this.y = 0;

        // Update power-ups
        if (this.doubleShot && this.doubleTimer > 0) {
          this.doubleTimer--;
        } else {
          this.doubleShot = false;
        }

        if (shieldActive && shieldTimer > 0) {
          shieldTimer--;
          shieldTimeSpan.textContent = Math.ceil(shieldTimer / 60);
        } else {
          shieldActive = false;
          shieldTimeSpan.textContent = 0;
        }
      }

      draw() {
        if (!this.active) return;
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.angle);

        const config = shipConfigs[selectedShip];
        
        // Enhanced ship design based on selection
        ctx.shadowBlur = 15;
        ctx.shadowColor = config.colors.primary;
        
        drawShipPreview(ctx, 0, 0, selectedShip, 1);

        ctx.restore();

        // Enhanced shield effect
        if (shieldActive) {
          ctx.save();
          ctx.translate(this.x, this.y);
          
          const time = Date.now() * 0.008;
          const pulseFactor = Math.sin(time * 3) * 0.3 + 1;
          const shieldRadius = (this.radius + 15) * pulseFactor;
          
          // Multiple shield layers
          for (let i = 0; i < 3; i++) {
            const radius = shieldRadius - i * 5;
            const opacity = 0.4 - i * 0.1;
            
            const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, radius);
            gradient.addColorStop(0, `rgba(0, 200, 255, ${opacity * 0.2})`);
            gradient.addColorStop(0.8, `rgba(0, 150, 255, ${opacity * 0.6})`);
            gradient.addColorStop(1, `rgba(0, 100, 255, ${opacity})`);
            
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(0, 0, radius, 0, Math.PI * 2);
            ctx.fill();
          }
          
          // Hexagon pattern
          ctx.strokeStyle = `rgba(0, 255, 255, ${0.8 * pulseFactor})`;
          ctx.lineWidth = 2;
          
          const hexRadius = this.radius + 12;
          const rotationAngle = time * 0.5;
          
          for (let layer = 0; layer < 2; layer++) {
            const currentRadius = hexRadius + layer * 8;
            const currentRotation = rotationAngle + layer * 0.5;
            
            ctx.beginPath();
            for (let i = 0; i < 6; i++) {
              const angle = (i * Math.PI) / 3 + currentRotation;
              const x = Math.cos(angle) * currentRadius;
              const y = Math.sin(angle) * currentRadius;
              
              if (i === 0) {
                ctx.moveTo(x, y);
              } else {
                ctx.lineTo(x, y);
              }
            }
            ctx.closePath();
            ctx.stroke();
          }
          
          ctx.restore();
        }
      }

      canShoot() {
        const config = shipConfigs[selectedShip];
        const adjustedCooldown = this.shootCooldown / config.powerMultiplier;
        return Date.now() - this.lastShot > adjustedCooldown;
      }

      shoot() {
        if (!this.canShoot() || !this.active) return;
        
        this.lastShot = Date.now();
        bullets.push(new Bullet(this.x, this.y, this.angle, 'player'));
        
        if (this.doubleShot) {
          bullets.push(new Bullet(this.x, this.y, this.angle + 0.15, 'player'));
          bullets.push(new Bullet(this.x, this.y, this.angle - 0.15, 'player'));
        }
      }
    }

    // Enhanced Bullet class with custom trail colors
    class Bullet {
      constructor(x, y, angle, owner = 'player') {
        this.x = x;
        this.y = y;
        this.angle = angle;
        this.owner = owner;
        this.speed = owner === 'player' ? 15 : 8;
        this.vel = {
          x: Math.cos(angle) * this.speed,
          y: Math.sin(angle) * this.speed
        };
        
        this.length = owner === 'player' ? 30 : 20;
        this.width = owner === 'player' ? 3 : 2;
        this.energy = 100;
        this.maxDistance = owner === 'player' ? 1000 : 800;
        this.distanceTraveled = 0;
        this.trail = [];
        this.maxTrailLength = owner === 'player' ? (isMobile ? 4 : 6) : 4; // Reduced trail on mobile
        this.glowIntensity = 1;
        this.active = true;
        
        // Enhanced damage based on ship config
        if (owner === 'player') {
          const config = shipConfigs[selectedShip];
          this.damage = Math.floor(10 * config.powerMultiplier);
        }
      }

      update() {
        if (!this.active) return;
        // Update position
        this.x += this.vel.x;
        this.y += this.vel.y;
        this.distanceTraveled += this.speed;
        
        // Add to trail
        this.trail.push({ x: this.x, y: this.y, intensity: this.glowIntensity });
        if (this.trail.length > this.maxTrailLength) {
          this.trail.shift();
        }
        
        // Fade out over distance
        this.energy = Math.max(0, 100 - (this.distanceTraveled / this.maxDistance) * 100);
        this.glowIntensity = this.energy / 100;
        
        // Create particle effects with custom trail effects - reduce on mobile
        if (Math.random() < (isMobile ? 0.05 : 0.15)) {
          const offsetAngle = this.angle + (Math.random() - 0.5) * 0.5;
          
          if (this.owner === 'player') {
            const trailParticle = trailEffectManager.createTrailParticle(
              this.x - Math.cos(this.angle) * 15,
              this.y - Math.sin(this.angle) * 15,
              offsetAngle,
              1,
              2
            );
            particles.push(trailParticle);
          } else {
            particles.push(new Particle(
              this.x - Math.cos(this.angle) * 15,
              this.y - Math.sin(this.angle) * 15,
              offsetAngle,
              1,
              '#ffaa00',
              2
            ));
          }
        }
        
        if (this.offscreen()) this.active = false;
      }

      draw() {
        if (!this.active || this.energy <= 0) return;
        
        ctx.save();
        
        // Draw trail with custom colors
        for (let i = 0; i < this.trail.length; i++) {
          const point = this.trail[i];
          const trailAlpha = (i / this.trail.length) * this.glowIntensity * 0.5;
          const trailSize = (i / this.trail.length) * this.width;
          
          ctx.globalAlpha = trailAlpha;
          let trailColor = this.owner === 'player' ? trailEffectManager.getCurrentColor() : '#ffcc88';
          
          ctx.fillStyle = trailColor;
          ctx.beginPath();
          ctx.arc(point.x, point.y, trailSize, 0, Math.PI * 2);
          ctx.fill();
        }
        
        // Draw main bullet
        ctx.globalAlpha = this.glowIntensity;
        ctx.translate(this.x, this.y);
        ctx.rotate(this.angle);
        
        // Glow effect
        ctx.shadowBlur = 20;
        let shadowColor = this.owner === 'player' ? trailEffectManager.getCurrentColor() : '#ffaa00';
        ctx.shadowColor = shadowColor;
        
        // Main bullet body
        const gradient = ctx.createLinearGradient(-this.length/2, 0, this.length/2, 0);
        if (this.owner === 'player') {
          const trailColor = trailEffectManager.getCurrentColor();
          gradient.addColorStop(0, `${trailColor}40`);
          gradient.addColorStop(0.5, '#ffffff');
          gradient.addColorStop(1, `${trailColor}CC`);
        } else {
          gradient.addColorStop(0, 'rgba(255, 170, 0, 0.2)');
          gradient.addColorStop(0.5, 'rgba(255, 255, 100, 1)');
          gradient.addColorStop(1, 'rgba(255, 170, 0, 0.8)');
        }
        
        ctx.fillStyle = gradient;
        ctx.fillRect(-this.length/2, -this.width/2, this.length, this.width);
        
        // Core
        ctx.fillStyle = '#ffffff';
        ctx.fillRect(-this.length/2, -this.width/4, this.length, this.width/2);
        
        ctx.restore();
      }

      offscreen() {
        return this.energy <= 0 || 
               this.x < -100 || this.x > window.innerWidth + 100 ||
               this.y < -100 || this.y > window.innerHeight + 100;
      }
    }

    // Enhanced Boss Enemy class with improved AI and phases
    class Boss {
      constructor(type = 'destroyer') {
        this.type = type;
        this.x = window.innerWidth / 2;
        this.y = -100;
        this.targetY = window.innerHeight * 0.2;
        this.radius = 60;
        
        // Enhanced boss health based on difficulty
        const diffConfig = difficultyManager.getCurrentConfig();
        this.maxHealth = diffConfig.bossHealth;
        this.health = this.maxHealth;
        this.speed = diffConfig.bossSpeed;
        
        this.angle = 0;
        this.active = true;
        this.phase = 'entering';
        this.lastShot = 0;
        this.shootCooldown = diffConfig.bossShootCooldown;
        this.lastSpecialAttack = 0;
        this.specialAttackCooldown = 3000;
        this.movePattern = 0;
        this.moveTimer = 0;
        this.pulsePhase = 0;
        this.damageReduction = 0.5;
        
        // Enhanced boss phases
        this.currentPhase = 1;
        this.maxPhases = 3;
        this.phaseTransition = false;
        this.lastPhaseChange = 0;
        
        // Store original health for regeneration
        originalBossHealth = this.maxHealth;
        
        // Boss specific properties
        if (type === 'destroyer') {
          this.name = 'VOID DESTROYER';
          this.color1 = '#cc0000';
          this.color2 = '#880000';
          this.color3 = '#ff4444';
        }
      }

      update(target) {
        if (!this.active) return;
        
        this.pulsePhase += 0.05;
        
        if (this.phase === 'entering') {
          this.y += 2;
          if (this.y >= this.targetY) {
            this.phase = 'fighting';
          }
          return;
        }
        
        // Enhanced movement patterns based on phase
        this.moveTimer += 0.02 * this.speed;
        
        if (this.currentPhase === 1) {
          // Phase 1: Basic movement
          this.x += Math.sin(this.moveTimer) * 2 * this.speed;
        } else if (this.currentPhase === 2) {
          // Phase 2: More aggressive movement
          this.x += Math.cos(this.moveTimer * 0.7) * 3 * this.speed;
          this.y += Math.sin(this.moveTimer * 0.5) * 1.5;
        } else if (this.currentPhase === 3) {
          // Phase 3: Erratic movement
          this.x += Math.sin(this.moveTimer * 1.5) * 4 * this.speed;
          this.y += Math.cos(this.moveTimer * 1.2) * 2;
        }
        
        // Keep boss on screen
        this.x = Math.max(this.radius, Math.min(window.innerWidth - this.radius, this.x));
        this.y = Math.max(this.radius, Math.min(window.innerHeight * 0.4, this.y));
        
        // Update angle to face player
        this.angle = Math.atan2(target.y - this.y, target.x - this.x);
        
        // Enhanced shooting patterns based on phase
        const adjustedCooldown = this.shootCooldown / this.currentPhase;
        if (Date.now() - this.lastShot > adjustedCooldown) {
          this.shoot(target);
        }
        
        // Enhanced special attacks
        const specialCooldown = this.specialAttackCooldown / (this.currentPhase * 0.8);
        if (Date.now() - this.lastSpecialAttack > specialCooldown) {
          this.specialAttack(target);
        }
        
        // Phase transitions based on health
        const healthPercent = this.health / this.maxHealth;
        if (healthPercent <= 0.66 && this.currentPhase === 1) {
          this.enterPhase(2);
        } else if (healthPercent <= 0.33 && this.currentPhase === 2) {
          this.enterPhase(3);
        }
        
        // Update health bar
        const healthPercent2 = (this.health / this.maxHealth) * 100;
        bossHealthFill.style.width = healthPercent2 + '%';
      }

      enterPhase(newPhase) {
        if (this.currentPhase >= newPhase || this.phaseTransition) return;
        
        this.currentPhase = newPhase;
        this.phaseTransition = true;
        this.lastPhaseChange = Date.now();
        
        // Visual effect for phase transition - reduce particles on mobile
        const particleCount = isMobile ? 8 : 15;
        for (let i = 0; i < particleCount; i++) {
          const angle = (Math.PI * 2 * i) / particleCount;
          particles.push(new Particle(
            this.x, this.y, angle, 8, 
            this.currentPhase === 2 ? '#ffaa00' : '#ff0000', 
            6
          ));
        }
        
        // Update boss name based on phase
        if (this.currentPhase === 2) {
          this.name = 'VOID DESTROYER - PHASE 2';
          bossName.textContent = this.name;
        } else if (this.currentPhase === 3) {
          this.name = 'VOID DESTROYER - FINAL PHASE';
          bossName.textContent = this.name;
        }
        
        setTimeout(() => {
          this.phaseTransition = false;
        }, 1000);
      }

      shoot(target) {
        this.lastShot = Date.now();
        
        if (this.currentPhase === 1) {
          // Phase 1: Single shot with slight inaccuracy
          const bulletAngle = this.angle + (Math.random() - 0.5) * 0.2;
          enemyBullets.push(new Bullet(this.x, this.y, bulletAngle, 'enemy'));
        } else if (this.currentPhase === 2) {
          // Phase 2: Double shot
          enemyBullets.push(new Bullet(this.x, this.y, this.angle - 0.1, 'enemy'));
          enemyBullets.push(new Bullet(this.x, this.y, this.angle + 0.1, 'enemy'));
        } else if (this.currentPhase === 3) {
          // Phase 3: Triple shot
          for (let i = -1; i <= 1; i++) {
            enemyBullets.push(new Bullet(this.x, this.y, this.angle + i * 0.15, 'enemy'));
          }
        }
      }

      specialAttack(target) {
        this.lastSpecialAttack = Date.now();
        
        if (this.currentPhase === 1) {
          // Phase 1: 5-way spread
          for (let i = 0; i < 5; i++) {
            const angle = (Math.PI * 2 * i) / 5;
            enemyBullets.push(new Bullet(this.x, this.y, angle, 'enemy'));
          }
        } else if (this.currentPhase === 2) {
          // Phase 2: 8-way spread + targeted shots
          for (let i = 0; i < 8; i++) {
            const angle = (Math.PI * 2 * i) / 8;
            enemyBullets.push(new Bullet(this.x, this.y, angle, 'enemy'));
          }
          // Add targeted shots
          for (let i = 0; i < 3; i++) {
            const targetAngle = this.angle + (i - 1) * 0.2;
            enemyBullets.push(new Bullet(this.x, this.y, targetAngle, 'enemy'));
          }
        } else if (this.currentPhase === 3) {
          // Phase 3: Spiral attack
          for (let i = 0; i < 12; i++) {
            const angle = (Math.PI * 2 * i) / 12 + this.moveTimer;
            enemyBullets.push(new Bullet(this.x, this.y, angle, 'enemy'));
          }
        }
      }

      takeDamage(amount, isShieldedHit = false) {
        // Reduced damage from shielded player collision
        const finalDamage = isShieldedHit ? amount * 0.3 : amount;
        this.health -= finalDamage;
        
        if (this.health <= 0) {
          this.active = false;
          return true; // Boss defeated
        }
        return false;
      }

      // Enhanced health regeneration when player dies
      regenerateHealth() {
        this.health = originalBossHealth;
        this.maxHealth = originalBossHealth;
        this.currentPhase = 1; // Reset to phase 1
        this.phaseTransition = false;
        this.name = 'VOID DESTROYER';
        bossName.textContent = this.name;
        
        // Update health bar to show full health
        const healthPercent = (this.health / this.maxHealth) * 100;
        bossHealthFill.style.width = healthPercent + '%';
      }

      draw() {
        if (!this.active) return;
        
        ctx.save();
        ctx.translate(this.x, this.y);
        
        // Enhanced pulsing effect based on phase
        const pulse = Math.sin(this.pulsePhase * this.currentPhase) * 0.2 + 1;
        ctx.scale(pulse, pulse);
        
        // Phase-based visual enhancements
        if (this.currentPhase >= 2) {
          ctx.shadowBlur = 35;
        } else {
          ctx.shadowBlur = 25;
        }
        ctx.shadowColor = this.color1;
        
        // Enhanced gradient based on phase
        const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, this.radius);
        if (this.currentPhase === 3) {
          gradient.addColorStop(0, '#ffffff');
          gradient.addColorStop(0.3, this.color3);
          gradient.addColorStop(0.6, this.color1);
          gradient.addColorStop(1, '#000000');
        } else if (this.currentPhase === 2) {
          gradient.addColorStop(0, this.color3);
          gradient.addColorStop(0.5, '#ffaa00');
          gradient.addColorStop(0.8, this.color1);
          gradient.addColorStop(1, this.color2);
        } else {
          gradient.addColorStop(0, this.color3);
          gradient.addColorStop(0.6, this.color1);
          gradient.addColorStop(1, this.color2);
        }
        
        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.arc(0, 0, this.radius, 0, Math.PI * 2);
        ctx.fill();
        
        // Enhanced boss details based on phase
        ctx.strokeStyle = this.currentPhase >= 2 ? '#ffaa00' : this.color3;
        ctx.lineWidth = this.currentPhase >= 3 ? 6 : 4;
        
        // Cross pattern
        ctx.beginPath();
        ctx.moveTo(-this.radius * 0.7, 0);
        ctx.lineTo(this.radius * 0.7, 0);
        ctx.moveTo(0, -this.radius * 0.7);
        ctx.lineTo(0, this.radius * 0.7);
        ctx.stroke();
        
        // Enhanced outer spikes based on phase
        const spikeCount = 8 + (this.currentPhase - 1) * 4;
        for (let i = 0; i < spikeCount; i++) {
          const angle = (Math.PI * 2 * i) / spikeCount + this.pulsePhase * 0.5;
          const innerRadius = this.radius * 0.8;
          const outerRadius = this.radius * (1.2 + this.currentPhase * 0.1);
          
          const x1 = Math.cos(angle) * innerRadius;
          const y1 = Math.sin(angle) * innerRadius;
          const x2 = Math.cos(angle) * outerRadius;
          const y2 = Math.sin(angle) * outerRadius;
          
          ctx.beginPath();
          ctx.moveTo(x1, y1);
          ctx.lineTo(x2, y2);
          ctx.stroke();
        }
        
        // Enhanced core based on phase
        ctx.fillStyle = this.currentPhase >= 3 ? '#ffff00' : '#ffffff';
        ctx.beginPath();
        ctx.arc(0, 0, this.radius * (0.3 + this.currentPhase * 0.05), 0, Math.PI * 2);
        ctx.fill();
        
        ctx.restore();
      }
    }

    // Enhanced Enemy class with difficulty-based behavior
    class Enemy {
      constructor() {
        const edge = Math.floor(Math.random() * 4);
        const padding = 100;
        
        if (edge === 0) {
          this.x = Math.random() * window.innerWidth;
          this.y = -padding;
        } else if (edge === 1) {
          this.x = window.innerWidth + padding;
          this.y = Math.random() * window.innerHeight;
        } else if (edge === 2) {
          this.x = Math.random() * window.innerWidth;
          this.y = window.innerHeight + padding;
        } else {
          this.x = -padding;
          this.y = Math.random() * window.innerHeight;
        }
        
        this.radius = 18;
        
        // Enhanced speed based on difficulty
        const diffConfig = difficultyManager.getCurrentConfig();
        this.speed = diffConfig.enemySpeed;
        
        this.health = 1;
        this.angle = 0;
        this.targetAngle = 0;
        this.angleSpeed = 0.05;
        this.active = true;
        
        // AI properties
        this.lastDirectionChange = 0;
        this.avoidanceRadius = 150;
        this.separationRadius = 80;
        this.cohesionRadius = 120;
        this.avoidanceStrength = 2;
        this.wanderAngle = Math.random() * Math.PI * 2;
        this.wanderSpeed = 0.02;
        
        // Enhanced shooting properties based on difficulty
        this.canShoot = Math.random() < diffConfig.enemyShootChance;
        this.lastShot = 0;
        this.shootCooldown = 2500 + Math.random() * 1000;
        this.shootRange = 250;
        
        // Visual properties
        this.pulsePhase = Math.random() * Math.PI * 2;
        this.trailPoints = [];
        this.maxTrailLength = isMobile ? 3 : 5; // Reduce trail on mobile
      }

      update(target, allEnemies) {
        if (!this.active) return;
        
        // Calculate forces
        const toTarget = this.getVectorTo(target);
        const avoidanceBullets = this.avoidBullets();
        const separation = this.separate(allEnemies);
        const cohesion = this.cohesion(allEnemies);
        
        // Combine forces
        let forceX = toTarget.x * 0.3 + avoidanceBullets.x * 2 + separation.x * 1.5 + cohesion.x * 0.5;
        let forceY = toTarget.y * 0.3 + avoidanceBullets.y * 2 + separation.y * 1.5 + cohesion.y * 0.5;
        
        // Add wandering
        this.wanderAngle += (Math.random() - 0.5) * this.wanderSpeed;
        forceX += Math.cos(this.wanderAngle) * 0.2;
        forceY += Math.sin(this.wanderAngle) * 0.2;
        
        // Calculate target angle
        this.targetAngle = Math.atan2(forceY, forceX);
        
        // Smooth angle interpolation
        let angleDiff = this.targetAngle - this.angle;
        while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
        while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;
        
        this.angle += angleDiff * this.angleSpeed;
        
        // Update position
        this.x += Math.cos(this.angle) * this.speed;
        this.y += Math.sin(this.angle) * this.speed;
        
        // Update trail
        this.trailPoints.push({ x: this.x, y: this.y });
        if (this.trailPoints.length > this.maxTrailLength) {
          this.trailPoints.shift();
        }
        
        // Update pulse
        this.pulsePhase += 0.1;
        
        // Enhanced shooting logic based on difficulty
        if (this.canShoot && target.active) {
          const distanceToTarget = Math.hypot(target.x - this.x, target.y - this.y);
          if (distanceToTarget < this.shootRange && Date.now() - this.lastShot > this.shootCooldown) {
            this.shoot(target);
          }
        }
      }

      shoot(target) {
        this.lastShot = Date.now();
        const angleToTarget = Math.atan2(target.y - this.y, target.x - this.x);
        
        // Add inaccuracy based on difficulty (more accurate on harder difficulties)
        const diffConfig = difficultyManager.getCurrentConfig();
        const inaccuracy = (Math.random() - 0.5) * (0.6 - diffConfig.enemyShootChance * 0.2);
        const finalAngle = angleToTarget + inaccuracy;
        
        enemyBullets.push(new Bullet(this.x, this.y, finalAngle, 'enemy'));
      }

      getVectorTo(target) {
        const dx = target.x - this.x;
        const dy = target.y - this.y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        return { x: dx / distance, y: dy / distance };
      }

      avoidBullets() {
        let avoidX = 0;
        let avoidY = 0;
        
        for (let bullet of bullets) {
          if (!bullet.active || bullet.owner !== 'player') continue;
          const dx = bullet.x - this.x;
          const dy = bullet.y - this.y;
          const distance = Math.sqrt(dx * dx + dy * dy);
          
          if (distance < this.avoidanceRadius && distance > 0) {
            const futureX = bullet.x + bullet.vel.x * 10;
            const futureY = bullet.y + bullet.vel.y * 10;
            const futureDistance = Math.sqrt((futureX - this.x) ** 2 + (futureY - this.y) ** 2);
            
            if (futureDistance < distance) {
              const force = (this.avoidanceRadius - distance) / this.avoidanceRadius;
              avoidX -= (dx / distance) * force;
              avoidY -= (dy / distance) * force;
            }
          }
        }
        
        return { x: avoidX, y: avoidY };
      }

      separate(enemies) {
        let separateX = 0;
        let separateY = 0;
        let count = 0;
        
        for (let enemy of enemies) {
          if (enemy === this || !enemy.active) continue;
          
          const dx = enemy.x - this.x;
          const dy = enemy.y - this.y;
          const distance = Math.sqrt(dx * dx + dy * dy);
          
          if (distance < this.separationRadius && distance > 0) {
            separateX -= dx / distance;
            separateY -= dy / distance;
            count++;
          }
        }
        
        if (count > 0) {
          separateX /= count;
          separateY /= count;
        }
        
        return { x: separateX, y: separateY };
      }

      cohesion(enemies) {
        let centerX = 0;
        let centerY = 0;
        let count = 0;
        
        for (let enemy of enemies) {
          if (enemy === this || !enemy.active) continue;
          
          const dx = enemy.x - this.x;
          const dy = enemy.y - this.y;
          const distance = Math.sqrt(dx * dx + dy * dy);
          
          if (distance < this.cohesionRadius) {
            centerX += enemy.x;
            centerY += enemy.y;
            count++;
          }
        }
        
        if (count > 0) {
          centerX /= count;
          centerY /= count;
          const dx = centerX - this.x;
          const dy = centerY - this.y;
          const distance = Math.sqrt(dx * dx + dy * dy);
          
          if (distance > 0) {
            return { x: dx / distance * 0.3, y: dy / distance * 0.3 };
          }
        }
        
        return { x: 0, y: 0 };
      }

      draw() {
        if (!this.active) return;
        ctx.save();
        
        // Draw trail
        for (let i = 0; i < this.trailPoints.length; i++) {
          const point = this.trailPoints[i];
          const alpha = (i / this.trailPoints.length) * 0.3;
          const size = (i / this.trailPoints.length) * this.radius * 0.5;
          
          ctx.globalAlpha = alpha;
          ctx.fillStyle = '#ff6666';
          ctx.beginPath();
          ctx.arc(point.x, point.y, size, 0, Math.PI * 2);
          ctx.fill();
        }
        
        // Draw main enemy
        ctx.globalAlpha = 1;
        ctx.translate(this.x, this.y);
        ctx.rotate(this.angle);
        
        // Pulsing glow
        const pulse = Math.sin(this.pulsePhase) * 0.3 + 0.7;
        ctx.shadowBlur = 15 * pulse;
        ctx.shadowColor = '#ff4444';
        
        // Main body
        const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, this.radius);
        gradient.addColorStop(0, '#ff8888');
        gradient.addColorStop(0.7, '#ff4444');
        gradient.addColorStop(1, '#cc0000');
        
        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.moveTo(this.radius, 0);
        ctx.lineTo(-this.radius * 0.8, -this.radius * 0.6);
        ctx.lineTo(-this.radius * 0.5, 0);
        ctx.lineTo(-this.radius * 0.8, this.radius * 0.6);
        ctx.closePath();
        ctx.fill();
        
        // Core
        ctx.fillStyle = '#ffffff';
        ctx.beginPath();
        ctx.arc(0, 0, this.radius * 0.3, 0, Math.PI * 2);
        ctx.fill();
        
        // Shooting capability indicator
        if (this.canShoot) {
          ctx.fillStyle = '#ffaa00';
          ctx.shadowColor = '#ffaa00';
          ctx.shadowBlur = 8;
          ctx.beginPath();
          ctx.arc(this.radius * 0.6, 0, 3, 0, Math.PI * 2);
          ctx.fill();
        }
        
        ctx.restore();
      }
    }

    // Enhanced PowerUp class
    class PowerUp {
      constructor(type) {
        this.x = Math.random() * (window.innerWidth - 200) + 100;
        this.y = Math.random() * (window.innerHeight - 200) + 100;
        this.type = type;
        this.radius = 25;
        this.pulseTime = 0;
        this.glowIntensity = 0;
        this.floatOffset = Math.random() * Math.PI * 2;
        this.baseY = this.y;
        this.particles = [];
        this.active = true;
      }

      update() {
        if (!this.active) return;
        this.pulseTime += 0.08;
        this.glowIntensity = Math.sin(this.pulseTime) * 0.4 + 0.6;
        
        // Floating effect
        this.y = this.baseY + Math.sin(this.pulseTime * 2) * 5;
        
        // Create particles - reduce on mobile
        if (Math.random() < (isMobile ? 0.05 : 0.15)) {
          const angle = Math.random() * Math.PI * 2;
          const speed = Math.random() * 2 + 1;
          const color = this.getParticleColor();
          this.particles.push(new Particle(
            this.x + Math.cos(angle) * this.radius,
            this.y + Math.sin(angle) * this.radius,
            angle,
            speed,
            color,
            3
          ));
        }
        
        // Update particles
        for (let i = this.particles.length - 1; i >= 0; i--) {
          this.particles[i].update();
          if (!this.particles[i].active) {
            this.particles.splice(i, 1);
          }
        }
      }

      getParticleColor() {
        if (this.type === "life") return "#00ff88";
        if (this.type === "double") return "#ffdd00";
        if (this.type === "shield") return "#00aaff";
        return "#ffffff";
      }

      draw() {
        if (!this.active) return;
        // Draw particles
        for (let particle of this.particles) {
          particle.draw();
        }
        
        ctx.save();
        ctx.translate(this.x, this.y);
        
        // Enhanced glow effect
        ctx.shadowBlur = 25;
        ctx.shadowColor = this.getGlowColor();
        
        // Outer ring
        ctx.beginPath();
        ctx.arc(0, 0, this.radius + 4, 0, Math.PI * 2);
        ctx.fillStyle = this.getOuterRingColor();
        ctx.fill();
        
        // Main body with enhanced gradient
        const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, this.radius);
        gradient.addColorStop(0, this.getGradientCenter());
        gradient.addColorStop(0.6, this.getGradientMid());
        gradient.addColorStop(1, this.getGradientEdge());
        
        ctx.beginPath();
        ctx.arc(0, 0, this.radius, 0, Math.PI * 2);
        ctx.fillStyle = gradient;
        ctx.fill();
        
        // Inner glow
        ctx.shadowBlur = 0;
        ctx.fillStyle = `rgba(255, 255, 255, ${this.glowIntensity * 0.3})`;
        ctx.beginPath();
        ctx.arc(0, 0, this.radius * 0.7, 0, Math.PI * 2);
        ctx.fill();
        
        // Icon
        this.drawIcon();
        
        ctx.restore();
      }

      getGlowColor() {
        if (this.type === "life") return `rgba(0, 255, 136, ${this.glowIntensity})`;
        if (this.type === "double") return `rgba(255, 221, 0, ${this.glowIntensity})`;
        if (this.type === "shield") return `rgba(0, 170, 255, ${this.glowIntensity})`;
      }

      getOuterRingColor() {
        if (this.type === "life") return "#00AA88";
        if (this.type === "double") return "#CC9900";
        if (this.type === "shield") return "#0088CC";
      }

      getGradientCenter() {
        if (this.type === "life") return "#00FF88";
        if (this.type === "double") return "#FFDD00";
        if (this.type === "shield") return "#00AAFF";
      }

      getGradientMid() {
        if (this.type === "life") return "#00DD66";
        if (this.type === "double") return "#DDAA00";
        if (this.type === "shield") return "#0088DD";
      }

      getGradientEdge() {
        if (this.type === "life") return "#00BB44";
        if (this.type === "double") return "#BB8800";
        if (this.type === "shield") return "#0066BB";
      }

      drawIcon() {
        ctx.strokeStyle = "white";
        ctx.fillStyle = "white";
        ctx.lineWidth = 3;
        ctx.lineCap = "round";
        ctx.lineJoin = "round";
        
        if (this.type === "life") {
          // Enhanced plus icon
          ctx.shadowBlur = 10;
          ctx.shadowColor = "white";
          ctx.beginPath();
          ctx.rect(-3, -10, 6, 20);
          ctx.fill();
          ctx.beginPath();
          ctx.rect(-10, -3, 20, 6);
          ctx.fill();
          
        } else if (this.type === "double") {
          // Enhanced multi-shot icon
          ctx.shadowBlur = 8;
          ctx.shadowColor = "white";
          
          // Draw arrows
          for (let i = 0; i < 3; i++) {
            const offsetY = (i - 1) * 8;
            ctx.beginPath();
            ctx.moveTo(-12, offsetY);
            ctx.lineTo(8, offsetY);
            ctx.moveTo(8, offsetY);
            ctx.lineTo(4, offsetY - 4);
            ctx.moveTo(8, offsetY);
            ctx.lineTo(4, offsetY + 4);
            ctx.stroke();
          }
          
        } else if (this.type === "shield") {
          // Enhanced shield icon
          ctx.shadowBlur = 10;
          ctx.shadowColor = "white";
          ctx.beginPath();
          ctx.moveTo(0, -12);
          ctx.lineTo(-10, -8);
          ctx.lineTo(-10, 4);
          ctx.lineTo(-5, 8);
          ctx.lineTo(0, 12);
          ctx.lineTo(5, 8);
          ctx.lineTo(10, 4);
          ctx.lineTo(10, -8);
          ctx.closePath();
          ctx.fill();
          
          // Shield details
          ctx.strokeStyle = "#0066BB";
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.moveTo(0, -8);
          ctx.lineTo(0, 8);
          ctx.moveTo(-6, -4);
          ctx.lineTo(6, -4);
          ctx.moveTo(-4, 2);
          ctx.lineTo(4, 2);
          ctx.stroke();
        }
      }
    }

    // Boss warning function
    function showBossWarning() {
      bossWarning.style.display = 'flex';
      setTimeout(() => {
        bossWarning.style.display = 'none';
      }, 2000);
    }

    // Game objects
    const ship = new Ship();
    const bullets = [];
    const enemies = [];

    // Game loop variables
    let spawnTimer = 0;
    let powerTimer = 0;
    let enemySpawnRate = 180;
    let waveLevel = 1;

    function initGame() {
      gameRunning = true;
      lives = 3;
      currentLives = 3;
      score = 0;
      shieldActive = false;
      shieldTimer = 0;
      
      // Enhanced spawn rate based on difficulty
      const diffConfig = difficultyManager.getCurrentConfig();
      enemySpawnRate = diffConfig.enemySpawnRate;
      
      waveLevel = 1;
      enemiesKilled = 0;
      nextBossAt = 20;
      bossActive = false;
      currentBoss = null;

      scoreSpan.textContent = score;
      highScoreManager.initializeDisplays();
      shieldTimeSpan.textContent = 0;
      gameOverScreen.style.display = "none";
      bossHealthContainer.style.display = "none";
      pauseManager.reset();

      // Clear arrays
      bullets.length = 0;
      enemies.length = 0;
      powerUps.length = 0;
      particles.length = 0;
      explosions.length = 0;
      enemyBullets.length = 0;

      // Reset ship
      ship.x = window.innerWidth / 2;
      ship.y = window.innerHeight / 2;
      ship.vel.x = 0;
      ship.vel.y = 0;
      ship.doubleShot = false;
      ship.doubleTimer = 0;
      ship.active = true;

      // Reset mobile controls
      if (isMobile) {
        resetJoystick();
        mobileControlManager.applySettings();
      } else {
        mouse.x = ship.x;
        mouse.y = ship.y;
      }

      createStars();
      createHearts();

      if (animationFrameId) {
        cancelAnimationFrame(animationFrameId);
      }
      animationFrameId = requestAnimationFrame(gameLoop);
    }

    function gameOver() {
      gameRunning = false;
      ship.active = false;
      
      // Enhanced boss health regeneration when player dies
      if (bossActive && currentBoss && currentBoss.active) {
        currentBoss.regenerateHealth();
      }
      
      // Increment games played counter
      highScoreManager.incrementGamesPlayed();
      
      fullscreenManager.hide();
      pauseManager.hide();
      audioBtn.style.display = 'none';
      if (animationFrameId) {
        cancelAnimationFrame(animationFrameId);
      }
      
      // Stop background music
      audioManager.stopBackgroundMusic();
      
      // Enhanced high score checking
      const isNewHighScore = highScoreManager.checkAndUpdateHighScore(score);
      
      finalScoreSpan.textContent = highScoreManager.formatScore(score);
      
      if (isNewHighScore) {
        highScoreMessage.style.display = 'block';
        highScoreMessage.classList.add('new-high-score');
        finalScoreSpan.classList.add('new-high-score');
      } else {
        highScoreMessage.style.display = 'none';
        highScoreMessage.classList.remove('new-high-score');
        finalScoreSpan.classList.remove('new-high-score');
      }
      
      gameOverScreen.style.display = "flex";
      bossHealthContainer.style.display = "none";
      
      // Create explosion at ship position
      explosions.push(new Explosion(ship.x, ship.y, 80));
    }

    function spawnBoss() {
      if (bossActive) return;
      
      showBossWarning();
      bossActive = true;
      
      setTimeout(() => {
        try {
          currentBoss = new Boss('destroyer');
          bossName.textContent = currentBoss.name;
          bossHealthContainer.style.display = 'block';
          
          // Clear regular enemies
          for (let enemy of enemies) {
            enemy.active = false;
          }
        } catch (error) {
          console.error('Error spawning boss:', error);
          bossActive = false;
        }
      }, 2000);
    }

    // Optimized game loop with enhanced mobile performance
    let lastFrameTime = 0;
    const targetFPS = isMobile ? 45 : 60; // Lower FPS target on mobile
    const frameInterval = 1000 / targetFPS;

    function gameLoop(currentTime) {
      if (!gameRunning || pauseManager.isPaused) return;

      // Enhanced FPS throttling for mobile performance
      if (currentTime - lastFrameTime < frameInterval) {
        animationFrameId = requestAnimationFrame(gameLoop);
        return;
      }
      lastFrameTime = currentTime;

      try {
        // Clear canvas with gradient background
        const gradient = ctx.createRadialGradient(window.innerWidth/2, window.innerHeight/2, 0, window.innerWidth/2, window.innerHeight/2, Math.max(window.innerWidth, window.innerHeight)/2);
        gradient.addColorStop(0, '#1a1a3e');
        gradient.addColorStop(1, '#000000');
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, window.innerWidth, window.innerHeight);

        // Draw enhanced stars with reduced processing on mobile
        for (let star of stars) {
          const twinkle = Math.sin(star.twinkle) * 0.3 + 0.7;
          ctx.fillStyle = star.color;
          ctx.globalAlpha = twinkle;
          if (!isMobile) {
            ctx.shadowBlur = star.size * 2;
            ctx.shadowColor = star.color;
          }
          ctx.fillRect(star.x, star.y, star.size, star.size);
          ctx.globalAlpha = 1;
          if (!isMobile) ctx.shadowBlur = 0;
        }

        // Update and draw particles (optimized)
        for (let i = particles.length - 1; i >= 0; i--) {
          const p = particles[i];
          p.update();
          if (!p.active) {
            particles.splice(i, 1);
          } else {
            p.draw();
          }
        }

        // Update and draw explosions
        for (let i = explosions.length - 1; i >= 0; i--) {
          const e = explosions[i];
          e.update();
          e.draw();
          if (!e.active) {
            explosions.splice(i, 1);
          }
        }

        // Update ship
        ship.update();
        ship.draw();

        // Check for boss spawn
        if (enemiesKilled >= nextBossAt && !bossActive) {
          spawnBoss();
          nextBossAt += 20;
        }

        // Enhanced boss update with error handling
        if (currentBoss && currentBoss.active) {
          try {
            currentBoss.update(ship);
            currentBoss.draw();
            
            // Check collision with player bullets
            for (let j = bullets.length - 1; j >= 0; j--) {
              const b = bullets[j];
              if (!b.active || b.owner !== 'player') continue;
              const bdx = currentBoss.x - b.x;
              const bdy = currentBoss.y - b.y;
              if (Math.hypot(bdx, bdy) < currentBoss.radius + b.width) {
                // Damage boss
                const defeated = currentBoss.takeDamage(b.damage || 10);
                explosions.push(new Explosion(b.x, b.y, 20));
                b.active = false;
                
                if (defeated) {
                  // Boss defeated - enhanced with error handling
                  try {
                    explosions.push(new Explosion(currentBoss.x, currentBoss.y, 100));
                    score += 500; // Bonus points for boss
                    scoreSpan.textContent = score;
                    bossActive = false;
                    currentBoss = null;
                    bossHealthContainer.style.display = 'none';
                    
                    // Spawn special power-up
                    powerUps.push(new PowerUp(['life', 'shield', 'double'][Math.floor(Math.random() * 3)]));
                  } catch (error) {
                    console.error('Error handling boss defeat:', error);
                    // Ensure cleanup even if error occurs
                    bossActive = false;
                    currentBoss = null;
                    bossHealthContainer.style.display = 'none';
                  }
                }
                break;
              }
            }
            
            // Enhanced boss collision mechanics
            if (ship.active) {
              const dx = currentBoss.x - ship.x;
              const dy = currentBoss.y - ship.y;
              const dist = Math.hypot(dx, dy);
              if (dist < currentBoss.radius + ship.radius) {
                if (shieldActive) {
                  // Reduced damage to boss with shield collision
                  const defeated = currentBoss.takeDamage(15, true);
                  explosions.push(new Explosion(currentBoss.x, currentBoss.y, 30));
                  if (defeated) {
                    try {
                      score += 500;
                      scoreSpan.textContent = score;
                      bossActive = false;
                      currentBoss = null;
                      bossHealthContainer.style.display = 'none';
                    } catch (error) {
                      console.error('Error handling boss defeat from collision:', error);
                      bossActive = false;
                      currentBoss = null;
                      bossHealthContainer.style.display = 'none';
                    }
                  }
                } else {
                  // Balanced player damage from boss collision
                  explosions.push(new Explosion(ship.x, ship.y, 50));
                  setLives(lives - 1);
                  if (lives <= 0) {
                    gameOver();
                    return;
                  }
                }
              }
            }
          } catch (error) {
            console.error('Error in boss update:', error);
            // Cleanup boss if error occurs
            bossActive = false;
            currentBoss = null;
            bossHealthContainer.style.display = 'none';
          }
        }

        // Enhanced enemy spawning based on difficulty
        if (!bossActive) {
          if (spawnTimer >= enemySpawnRate) {
            enemies.push(new Enemy());
            spawnTimer = 0;
            
            // Increase difficulty
            if (enemySpawnRate > 60) {
              enemySpawnRate -= 0.5;
            }
            
            // Wave progression
            if (enemiesKilled > 0 && enemiesKilled % 10 === 0) {
              waveLevel++;
              const diffConfig = difficultyManager.getCurrentConfig();
              enemySpawnRate = Math.max(60, diffConfig.enemySpawnRate - waveLevel * 15);
            }
          } else {
            spawnTimer++;
          }
        }

        // Update enemies
        for (let i = enemies.length - 1; i >= 0; i--) {
          const e = enemies[i];
          if (!e.active) {
            enemies.splice(i, 1);
            continue;
          }
          
          e.update(ship, enemies);
          e.draw();
          
          // Check collision with ship
          if (ship.active) {
            const dx = e.x - ship.x;
            const dy = e.y - ship.y;
            const dist = Math.hypot(dx, dy);
            if (dist < e.radius + ship.radius) {
              if (shieldActive) {
                // Destroy enemy if shield is active
                explosions.push(new Explosion(e.x, e.y, 40));
                e.active = false;
                score += 2; // Bonus points for shield kill
                scoreSpan.textContent = score;
              } else {
                // Damage player
                explosions.push(new Explosion(e.x, e.y, 50));
                e.active = false;
                setLives(lives - 1);
                if (lives <= 0) {
                  gameOver();
                  return;
                }
              }
              continue;
            }
          }

          // Check collision with player bullets
          for (let j = bullets.length - 1; j >= 0; j--) {
            const b = bullets[j];
            if (!b.active || b.owner !== 'player') continue;
            const bdx = e.x - b.x;
            const bdy = e.y - b.y;
            if (Math.hypot(bdx, bdy) < e.radius + b.width) {
              // Create explosion
              explosions.push(new Explosion(e.x, e.y, 30));
              
              // Remove enemy and bullet
              e.active = false;
              b.active = false;
              
              // Increase score
              score += 10;
              enemiesKilled++;
              scoreSpan.textContent = score;
              break;
            }
          }
        }

        // Enhanced enemy bullets update
        const diffConfig = difficultyManager.getCurrentConfig();
        if (diffConfig.enemyShootChance > 0 || bossActive) {
          for (let i = enemyBullets.length - 1; i >= 0; i--) {
            const b = enemyBullets[i];
            if (!b.active) {
              enemyBullets.splice(i, 1);
              continue;
            }
            
            b.update();
            b.draw();
            
            if (b.offscreen()) {
              b.active = false;
              continue;
            }
            
            // Check collision with ship
            if (ship.active) {
              const dx = ship.x - b.x;
              const dy = ship.y - b.y;
              if (Math.hypot(dx, dy) < ship.radius + b.width) {
                if (shieldActive) {
                  // Bullet destroyed by shield
                  explosions.push(new Explosion(b.x, b.y, 20));
                  b.active = false;
                } else {
                  // Damage player
                  explosions.push(new Explosion(b.x, b.y, 25));
                  b.active = false;
                  setLives(lives - 1);
                  if (lives <= 0) {
                    gameOver();
                    return;
                  }
                }
              }
            }
          }
        }

        // Spawn power-ups
        powerTimer++;
        if (powerTimer > 900) { // Every 15 seconds at 60fps
          const types = ["life", "double", "shield"];
          const type = types[Math.floor(Math.random() * types.length)];
          powerUps.push(new PowerUp(type));
          powerTimer = 0;
        }

        // Update power-ups
        for (let i = powerUps.length - 1; i >= 0; i--) {
          const p = powerUps[i];
          if (!p.active) {
            powerUps.splice(i, 1);
            continue;
          }
          
          p.update();
          p.draw();
          
          if (ship.active) {
            const dx = p.x - ship.x;
            const dy = p.y - ship.y;
            if (Math.hypot(dx, dy) < p.radius + ship.radius) {
              if (p.type === "life") {
                setLives(Math.min(maxLives, lives + 1));
              } else if (p.type === "double") {
                ship.doubleShot = true;
                ship.doubleTimer = 900; // 15 seconds
              } else if (p.type === "shield") {
                shieldActive = true;
                shieldTimer = 600; // 10 seconds
                shieldTimeSpan.textContent = Math.ceil(shieldTimer / 60);
              }
              
              // Create pickup effect - reduce particles on mobile
              const particleCount = isMobile ? 3 : 8;
              for (let j = 0; j < particleCount; j++) {
                const angle = (Math.PI * 2 * j) / particleCount;
                particles.push(new Particle(p.x, p.y, angle, 3, p.getParticleColor(), 5));
              }
              
              p.active = false;
            }
          }
        }

        // Update bullets
        for (let i = bullets.length - 1; i >= 0; i--) {
          const b = bullets[i];
          if (!b.active) {
            bullets.splice(i, 1);
            continue;
          }
          b.update();
          b.draw();
          if (b.offscreen()) {
            b.active = false;
          }
        }

      } catch (error) {
        console.error('Error in game loop:', error);
        // Continue game loop even if error occurs
      }

      animationFrameId = requestAnimationFrame(gameLoop);
    }

    // Controls
    function fireBullet() {
      ship.shoot();
    }

    // PC Controls
    document.addEventListener("mousemove", e => {
      if (!isMobile && gameRunning) {
        mouse.x = e.clientX;
        mouse.y = e.clientY;
      }
    });

    document.addEventListener("keydown", e => {
      if (!isMobile && gameRunning) {
        keys[e.key.toLowerCase()] = true;
        if (e.key === ' ' || e.key === 'Enter') {
          e.preventDefault();
          fireBullet();
        }
      }
    });

    document.addEventListener("keyup", e => {
      if (!isMobile && gameRunning) {
        keys[e.key.toLowerCase()] = false;
      }
    });

    document.addEventListener("mousedown", e => {
      if (!isMobile && e.button === 0 && gameRunning) {
        fireBullet();
      }
    });

    // Enhanced Mobile Controls with iOS optimizations
    let joystickActive = false;
    let joystickTouchId = null;
    let shootingInterval = null;
    let joystickCenter = { x: 0, y: 0 };
    let maxJoystickDistance = 0;

    function resetJoystick() {
      if (isMobile) {
        joystick.style.transform = 'translate(0px, 0px)';
        joystick.classList.remove('active');
        joystickActive = false;
        joystickTouchId = null;
      }
    }

    function updateJoystickCenter() {
      if (!isMobile) return;
      const containerRect = joystickContainer.getBoundingClientRect();
      joystickCenter.x = containerRect.left + containerRect.width / 2;
      joystickCenter.y = containerRect.top + containerRect.height / 2;
      maxJoystickDistance = (containerRect.width / 2) - (joystick.clientWidth / 2) - 5;
    }

    if (isMobile) {
      // Force controls to be visible immediately
      mobileControlsDiv.style.display = "flex";
      mobileControlsDiv.style.opacity = "1";
      mobileControlsDiv.style.visibility = "visible";
      
      // Force individual control visibility
      joystickContainer.style.opacity = "1";
      joystickContainer.style.visibility = "visible";
      joystickContainer.style.display = "flex";
      
      shootButton.style.opacity = "1";
      shootButton.style.visibility = "visible";
      shootButton.style.display = "flex";
      
      joystick.style.opacity = "1";
      joystick.style.visibility = "visible";

      // Apply mobile control settings
      mobileControlManager.applySettings();

      // Update joystick center on resize and orientation change
      window.addEventListener('resize', () => {
        updateJoystickCenter();
        mobileControlManager.applySettings();
      });
      window.addEventListener('orientationchange', () => {
        setTimeout(() => {
          updateJoystickCenter();
          mobileControlManager.applySettings();
        }, 100);
      });
      updateJoystickCenter();

      // Enhanced touch events with iOS-specific optimizations
      joystickContainer.addEventListener("touchstart", (e) => {
        if (!gameRunning || joystickTouchId !== null) return;
        e.preventDefault();
        e.stopPropagation();
        
        const touch = e.changedTouches[0];
        joystickTouchId = touch.identifier;
        joystickActive = true;
        joystick.classList.add('active');
        
        updateJoystickCenter();
      }, { passive: false, capture: true });

      // Enhanced shoot button with iOS optimizations
      shootButton.addEventListener("touchstart", (e) => {
        if (!gameRunning) return;
        e.preventDefault();
        e.stopPropagation();
        shootButton.classList.add('active');
        fireBullet();
        
        // Optimized shooting interval for iOS
        const shootInterval = isIOS ? 150 : 120; // Slightly slower on iOS
        shootingInterval = setInterval(() => {
          if (gameRunning) {
            fireBullet();
          }
        }, shootInterval);
      }, { passive: false, capture: true });

      shootButton.addEventListener("touchend", (e) => {
        e.preventDefault();
        e.stopPropagation();
        shootButton.classList.remove('active');
        if (shootingInterval) {
          clearInterval(shootingInterval);
          shootingInterval = null;
        }
      }, { passive: false, capture: true });

      // Enhanced global touch move with iOS optimizations
      document.addEventListener("touchmove", (e) => {
        if (!gameRunning || joystickTouchId === null) return;
        e.preventDefault();

        for (let i = 0; i < e.changedTouches.length; i++) {
          const touch = e.changedTouches[i];
          if (touch.identifier === joystickTouchId) {
            let deltaX = touch.clientX - joystickCenter.x;
            let deltaY = touch.clientY - joystickCenter.y;

            const distance = Math.hypot(deltaX, deltaY);
            
            if (distance > maxJoystickDistance) {
              const angle = Math.atan2(deltaY, deltaX);
              deltaX = Math.cos(angle) * maxJoystickDistance;
              deltaY = Math.sin(angle) * maxJoystickDistance;
            }

            // Use transform for better performance on iOS
            joystick.style.transform = `translate(${deltaX}px, ${deltaY}px)`;
            joystick.style.webkitTransform = `translate(${deltaX}px, ${deltaY}px)`; // iOS fallback
            break;
          }
        }
      }, { passive: false });

      // Enhanced global touch end with iOS handling
      document.addEventListener("touchend", (e) => {
        if (!gameRunning) return;

        for (let i = 0; i < e.changedTouches.length; i++) {
          const touch = e.changedTouches[i];
          if (touch.identifier === joystickTouchId) {
            resetJoystick();
            break;
          }
        }
        
        if (shootingInterval) {
          clearInterval(shootingInterval);
          shootingInterval = null;
        }
        shootButton.classList.remove('active');
      }, { passive: false });

      // Enhanced touch cancel for iOS
      document.addEventListener("touchcancel", (e) => {
        resetJoystick();
        if (shootingInterval) {
          clearInterval(shootingInterval);
          shootingInterval = null;
        }
        shootButton.classList.remove('active');
      }, { passive: false });

      // iOS-specific visibility fix
      if (isIOS) {
        // Force redraw on iOS to ensure visibility
        setTimeout(() => {
          mobileControlsDiv.style.transform = 'translateZ(0)';
          joystickContainer.style.transform = 'translateZ(0)';
          shootButton.style.transform = 'translateZ(0)';
          joystick.style.transform = 'translateZ(0)';
          
          // Force a repaint
          mobileControlsDiv.offsetHeight;
        }, 100);
      }

    } else {
      mobileControlsDiv.style.display = "none";
    }

    // Enhanced Game Over Button Event Listeners
    restartButton.addEventListener("click", () => {
      fullscreenManager.show();
      pauseManager.show();
      audioBtn.style.display = 'block';
      resizeCanvas();
      initGame();
      // Start background music when game restarts with random track
      audioManager.restartBackgroundMusic();
      // Auto-enter fullscreen on restart
      setTimeout(() => {
        fullscreenManager.autoEnterFullscreen();
      }, 500);
    });

    customizeButton.addEventListener("click", () => {
      gameOverScreen.style.display = "none";
      fullscreenManager.hide();
      pauseManager.hide();
      audioBtn.style.display = 'none';
      showCustomizationScreen();
    });

    difficultyButton.addEventListener("click", () => {
      gameOverScreen.style.display = "none";
      fullscreenManager.hide();
      pauseManager.hide();
      audioBtn.style.display = 'none';
      showDifficultyScreen();
    });

    // New Home Button Event Listener
    homeButton.addEventListener("click", () => {
      gameOverScreen.style.display = "none";
      fullscreenManager.hide();
      pauseManager.hide();
      audioBtn.style.display = 'none';
      showHomeScreen();
    });

    // Initialize
    resizeCanvas();
    
    // iOS-specific initialization
    if (isIOS) {
      // Ensure audio context is properly initialized on iOS
      document.addEventListener('touchstart', function initAudioOnIOS() {
        if (audioManager.audioContext && audioManager.audioContext.state === 'suspended') {
          audioManager.audioContext.resume();
        }
        document.removeEventListener('touchstart', initAudioOnIOS);
      }, { once: true });
    }
    
    // Initialize mobile control settings
    if (isMobile) {
      mobileControlManager.applySettings();
    }
  </script>
</body>
</html>
